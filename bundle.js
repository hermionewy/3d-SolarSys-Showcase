!function(g){var I={};function C(n){if(I[n])return I[n].exports;var e=I[n]={i:n,l:!1,exports:{}};return g[n].call(e.exports,e,e.exports,C),e.l=!0,e.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:n})},C.r=function(g){Object.defineProperty(g,"__esModule",{value:!0})},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=6)}([function(module,exports){eval("/*!\r\n  * Stickyfill – `position: sticky` polyfill\r\n  * v. 2.0.5 | https://github.com/wilddeer/stickyfill\r\n  * MIT License\r\n  */\r\n\r\n;(function(window, document) {\r\n    'use strict';\r\n    \r\n    /*\r\n     * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\r\n     *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\r\n     *    of the polyfill, but the API will remain functional to avoid breaking things.\r\n     */\r\n    \r\n    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n    \r\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n    \r\n    var seppuku = false;\r\n    \r\n    // The polyfill cant’t function properly without `getComputedStyle`.\r\n    if (!window.getComputedStyle) seppuku = true;\r\n    // Dont’t get in a way if the browser supports `position: sticky` natively.\r\n    else {\r\n            var testNode = document.createElement('div');\r\n    \r\n            if (['', '-webkit-', '-moz-', '-ms-'].some(function (prefix) {\r\n                try {\r\n                    testNode.style.position = prefix + 'sticky';\r\n                } catch (e) {}\r\n    \r\n                return testNode.style.position != '';\r\n            })) seppuku = true;\r\n        }\r\n    \r\n    /*\r\n     * 2. “Global” vars used across the polyfill\r\n     */\r\n    \r\n    // Check if Shadow Root constructor exists to make further checks simpler\r\n    var shadowRootExists = typeof ShadowRoot !== 'undefined';\r\n    \r\n    // Last saved scroll position\r\n    var scroll = {\r\n        top: null,\r\n        left: null\r\n    };\r\n    \r\n    // Array of created Sticky instances\r\n    var stickies = [];\r\n    \r\n    /*\r\n     * 3. Utility functions\r\n     */\r\n    function extend(targetObj, sourceObject) {\r\n        for (var key in sourceObject) {\r\n            if (sourceObject.hasOwnProperty(key)) {\r\n                targetObj[key] = sourceObject[key];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function parseNumeric(val) {\r\n        return parseFloat(val) || 0;\r\n    }\r\n    \r\n    function getDocOffsetTop(node) {\r\n        var docOffsetTop = 0;\r\n    \r\n        while (node) {\r\n            docOffsetTop += node.offsetTop;\r\n            node = node.offsetParent;\r\n        }\r\n    \r\n        return docOffsetTop;\r\n    }\r\n    \r\n    /*\r\n     * 4. Sticky class\r\n     */\r\n    \r\n    var Sticky = function () {\r\n        function Sticky(node) {\r\n            _classCallCheck(this, Sticky);\r\n    \r\n            if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');\r\n            if (stickies.some(function (sticky) {\r\n                return sticky._node === node;\r\n            })) throw new Error('Stickyfill is already applied to this node');\r\n    \r\n            this._node = node;\r\n            this._stickyMode = null;\r\n            this._active = false;\r\n    \r\n            stickies.push(this);\r\n    \r\n            this.refresh();\r\n        }\r\n    \r\n        _createClass(Sticky, [{\r\n            key: 'refresh',\r\n            value: function refresh() {\r\n                if (seppuku || this._removed) return;\r\n                if (this._active) this._deactivate();\r\n    \r\n                var node = this._node;\r\n    \r\n                /*\r\n                 * 1. Save node computed props\r\n                 */\r\n                var nodeComputedStyle = getComputedStyle(node);\r\n                var nodeComputedProps = {\r\n                    top: nodeComputedStyle.top,\r\n                    display: nodeComputedStyle.display,\r\n                    marginTop: nodeComputedStyle.marginTop,\r\n                    marginBottom: nodeComputedStyle.marginBottom,\r\n                    marginLeft: nodeComputedStyle.marginLeft,\r\n                    marginRight: nodeComputedStyle.marginRight,\r\n                    cssFloat: nodeComputedStyle.cssFloat\r\n                };\r\n    \r\n                /*\r\n                 * 2. Check if the node can be activated\r\n                 */\r\n                if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;\r\n    \r\n                this._active = true;\r\n    \r\n                /*\r\n                 * 3. Get necessary node parameters\r\n                 */\r\n                var referenceNode = node.parentNode;\r\n                var parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;\r\n                var nodeWinOffset = node.getBoundingClientRect();\r\n                var parentWinOffset = parentNode.getBoundingClientRect();\r\n                var parentComputedStyle = getComputedStyle(parentNode);\r\n    \r\n                this._parent = {\r\n                    node: parentNode,\r\n                    styles: {\r\n                        position: parentNode.style.position\r\n                    },\r\n                    offsetHeight: parentNode.offsetHeight\r\n                };\r\n                this._offsetToWindow = {\r\n                    left: nodeWinOffset.left,\r\n                    right: document.documentElement.clientWidth - nodeWinOffset.right\r\n                };\r\n                this._offsetToParent = {\r\n                    top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),\r\n                    left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),\r\n                    right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)\r\n                };\r\n                this._styles = {\r\n                    position: node.style.position,\r\n                    top: node.style.top,\r\n                    bottom: node.style.bottom,\r\n                    left: node.style.left,\r\n                    right: node.style.right,\r\n                    width: node.style.width,\r\n                    marginTop: node.style.marginTop,\r\n                    marginLeft: node.style.marginLeft,\r\n                    marginRight: node.style.marginRight\r\n                };\r\n    \r\n                var nodeTopValue = parseNumeric(nodeComputedProps.top);\r\n                this._limits = {\r\n                    start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\r\n                    end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)\r\n                };\r\n    \r\n                /*\r\n                 * 4. Ensure that the node will be positioned relatively to the parent node\r\n                 */\r\n                var parentPosition = parentComputedStyle.position;\r\n    \r\n                if (parentPosition != 'absolute' && parentPosition != 'relative') {\r\n                    parentNode.style.position = 'relative';\r\n                }\r\n    \r\n                /*\r\n                 * 5. Recalc node position.\r\n                 *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\r\n                 */\r\n                this._recalcPosition();\r\n    \r\n                /*\r\n                 * 6. Create a clone\r\n                 */\r\n                var clone = this._clone = {};\r\n                clone.node = document.createElement('div');\r\n    \r\n                // Apply styles to the clone\r\n                extend(clone.node.style, {\r\n                    width: nodeWinOffset.right - nodeWinOffset.left + 'px',\r\n                    height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\r\n                    marginTop: nodeComputedProps.marginTop,\r\n                    marginBottom: nodeComputedProps.marginBottom,\r\n                    marginLeft: nodeComputedProps.marginLeft,\r\n                    marginRight: nodeComputedProps.marginRight,\r\n                    cssFloat: nodeComputedProps.cssFloat,\r\n                    padding: 0,\r\n                    border: 0,\r\n                    borderSpacing: 0,\r\n                    fontSize: '1em',\r\n                    position: 'static'\r\n                });\r\n    \r\n                referenceNode.insertBefore(clone.node, node);\r\n                clone.docOffsetTop = getDocOffsetTop(clone.node);\r\n            }\r\n        }, {\r\n            key: '_recalcPosition',\r\n            value: function _recalcPosition() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                var stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';\r\n    \r\n                if (this._stickyMode == stickyMode) return;\r\n    \r\n                switch (stickyMode) {\r\n                    case 'start':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: this._offsetToParent.top + 'px',\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'middle':\r\n                        extend(this._node.style, {\r\n                            position: 'fixed',\r\n                            left: this._offsetToWindow.left + 'px',\r\n                            right: this._offsetToWindow.right + 'px',\r\n                            top: this._styles.top,\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'end':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: 'auto',\r\n                            bottom: 0,\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0\r\n                        });\r\n                        break;\r\n                }\r\n    \r\n                this._stickyMode = stickyMode;\r\n            }\r\n        }, {\r\n            key: '_fastCheck',\r\n            value: function _fastCheck() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();\r\n            }\r\n        }, {\r\n            key: '_deactivate',\r\n            value: function _deactivate() {\r\n                var _this = this;\r\n    \r\n                if (!this._active || this._removed) return;\r\n    \r\n                this._clone.node.parentNode.removeChild(this._clone.node);\r\n                delete this._clone;\r\n    \r\n                extend(this._node.style, this._styles);\r\n                delete this._styles;\r\n    \r\n                // Check whether element’s parent node is used by other stickies.\r\n                // If not, restore parent node’s styles.\r\n                if (!stickies.some(function (sticky) {\r\n                    return sticky !== _this && sticky._parent && sticky._parent.node === _this._parent.node;\r\n                })) {\r\n                    extend(this._parent.node.style, this._parent.styles);\r\n                }\r\n                delete this._parent;\r\n    \r\n                this._stickyMode = null;\r\n                this._active = false;\r\n    \r\n                delete this._offsetToWindow;\r\n                delete this._offsetToParent;\r\n                delete this._limits;\r\n            }\r\n        }, {\r\n            key: 'remove',\r\n            value: function remove() {\r\n                var _this2 = this;\r\n    \r\n                this._deactivate();\r\n    \r\n                stickies.some(function (sticky, index) {\r\n                    if (sticky._node === _this2._node) {\r\n                        stickies.splice(index, 1);\r\n                        return true;\r\n                    }\r\n                });\r\n    \r\n                this._removed = true;\r\n            }\r\n        }]);\r\n    \r\n        return Sticky;\r\n    }();\r\n    \r\n    /*\r\n     * 5. Stickyfill API\r\n     */\r\n    \r\n    \r\n    var Stickyfill = {\r\n        stickies: stickies,\r\n        Sticky: Sticky,\r\n    \r\n        addOne: function addOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Check if Stickyfill is already applied to the node\r\n            // and return existing sticky\r\n            for (var i = 0; i < stickies.length; i++) {\r\n                if (stickies[i]._node === node) return stickies[i];\r\n            }\r\n    \r\n            // Create and return new sticky\r\n            return new Sticky(node);\r\n        },\r\n        add: function add(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Add every element as a sticky and return an array of created Sticky instances\r\n            var addedStickies = [];\r\n    \r\n            var _loop = function _loop(i) {\r\n                var node = nodeList[i];\r\n    \r\n                // If it’s not an HTMLElement – create an empty element to preserve 1-to-1\r\n                // correlation with input list\r\n                if (!(node instanceof HTMLElement)) {\r\n                    addedStickies.push(void 0);\r\n                    return 'continue';\r\n                }\r\n    \r\n                // If Stickyfill is already applied to the node\r\n                // add existing sticky\r\n                if (stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        addedStickies.push(sticky);\r\n                        return true;\r\n                    }\r\n                })) return 'continue';\r\n    \r\n                // Create and add new sticky\r\n                addedStickies.push(new Sticky(node));\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                var _ret = _loop(i);\r\n    \r\n                if (_ret === 'continue') continue;\r\n            }\r\n    \r\n            return addedStickies;\r\n        },\r\n        refreshAll: function refreshAll() {\r\n            stickies.forEach(function (sticky) {\r\n                return sticky.refresh();\r\n            });\r\n        },\r\n        removeOne: function removeOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n            stickies.some(function (sticky) {\r\n                if (sticky._node === node) {\r\n                    sticky.remove();\r\n                    return true;\r\n                }\r\n            });\r\n        },\r\n        remove: function remove(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n    \r\n            var _loop2 = function _loop2(i) {\r\n                var node = nodeList[i];\r\n    \r\n                stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        sticky.remove();\r\n                        return true;\r\n                    }\r\n                });\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                _loop2(i);\r\n            }\r\n        },\r\n        removeAll: function removeAll() {\r\n            while (stickies.length) {\r\n                stickies[0].remove();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /*\r\n     * 6. Setup events (unless the polyfill was disabled)\r\n     */\r\n    function init() {\r\n        // Watch for scroll position changes and trigger recalc/refresh if needed\r\n        function checkScroll() {\r\n            if (window.pageXOffset != scroll.left) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                Stickyfill.refreshAll();\r\n            } else if (window.pageYOffset != scroll.top) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                // recalc position for all stickies\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._recalcPosition();\r\n                });\r\n            }\r\n        }\r\n    \r\n        checkScroll();\r\n        window.addEventListener('scroll', checkScroll);\r\n    \r\n        // Watch for window resizes and device orientation changes and trigger refresh\r\n        window.addEventListener('resize', Stickyfill.refreshAll);\r\n        window.addEventListener('orientationchange', Stickyfill.refreshAll);\r\n    \r\n        //Fast dirty check for layout changes every 500ms\r\n        var fastCheckTimer = void 0;\r\n    \r\n        function startFastCheckTimer() {\r\n            fastCheckTimer = setInterval(function () {\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._fastCheck();\r\n                });\r\n            }, 500);\r\n        }\r\n    \r\n        function stopFastCheckTimer() {\r\n            clearInterval(fastCheckTimer);\r\n        }\r\n    \r\n        var docHiddenKey = void 0;\r\n        var visibilityChangeEventName = void 0;\r\n    \r\n        if ('hidden' in document) {\r\n            docHiddenKey = 'hidden';\r\n            visibilityChangeEventName = 'visibilitychange';\r\n        } else if ('webkitHidden' in document) {\r\n            docHiddenKey = 'webkitHidden';\r\n            visibilityChangeEventName = 'webkitvisibilitychange';\r\n        }\r\n    \r\n        if (visibilityChangeEventName) {\r\n            if (!document[docHiddenKey]) startFastCheckTimer();\r\n    \r\n            document.addEventListener(visibilityChangeEventName, function () {\r\n                if (document[docHiddenKey]) {\r\n                    stopFastCheckTimer();\r\n                } else {\r\n                    startFastCheckTimer();\r\n                }\r\n            });\r\n        } else startFastCheckTimer();\r\n    }\r\n    \r\n    if (!seppuku) init();\r\n    \r\n    /*\r\n     * 7. Expose Stickyfill\r\n     */\r\n    if (typeof module != 'undefined' && module.exports) {\r\n        module.exports = Stickyfill;\r\n    } else {\r\n        window.Stickyfill = Stickyfill;\r\n    }\r\n    \r\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGlja3lmaWxsanMvZGlzdC9zdGlja3lmaWxsLmpzP2U2NzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAgKiBTdGlja3lmaWxsIOKAkyBgcG9zaXRpb246IHN0aWNreWAgcG9seWZpbGxcclxuICAqIHYuIDIuMC41IHwgaHR0cHM6Ly9naXRodWIuY29tL3dpbGRkZWVyL3N0aWNreWZpbGxcclxuICAqIE1JVCBMaWNlbnNlXHJcbiAgKi9cclxuXHJcbjsoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgICogMS4gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYHBvc2l0aW9uOiBzdGlja3lgIG5hdGl2ZWx5IG9yIGlzIHRvbyBvbGQgdG8gcnVuIHRoZSBwb2x5ZmlsbC5cclxuICAgICAqICAgIElmIGVpdGhlciBvZiB0aGVzZSBpcyB0aGUgY2FzZSBzZXQgYHNlcHB1a3VgIGZsYWcuIEl0IHdpbGwgYmUgY2hlY2tlZCBsYXRlciB0byBkaXNhYmxlIGtleSBmZWF0dXJlc1xyXG4gICAgICogICAgb2YgdGhlIHBvbHlmaWxsLCBidXQgdGhlIEFQSSB3aWxsIHJlbWFpbiBmdW5jdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIHRoaW5ncy5cclxuICAgICAqL1xyXG4gICAgXHJcbiAgICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG4gICAgXHJcbiAgICB2YXIgc2VwcHVrdSA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvLyBUaGUgcG9seWZpbGwgY2FudOKAmXQgZnVuY3Rpb24gcHJvcGVybHkgd2l0aG91dCBgZ2V0Q29tcHV0ZWRTdHlsZWAuXHJcbiAgICBpZiAoIXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSBzZXBwdWt1ID0gdHJ1ZTtcclxuICAgIC8vIERvbnTigJl0IGdldCBpbiBhIHdheSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBgcG9zaXRpb246IHN0aWNreWAgbmF0aXZlbHkuXHJcbiAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBcclxuICAgICAgICAgICAgaWYgKFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nXS5zb21lKGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdE5vZGUuc3R5bGUucG9zaXRpb24gPSBwcmVmaXggKyAnc3RpY2t5JztcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0Tm9kZS5zdHlsZS5wb3NpdGlvbiAhPSAnJztcclxuICAgICAgICAgICAgfSkpIHNlcHB1a3UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgLypcclxuICAgICAqIDIuIOKAnEdsb2JhbOKAnSB2YXJzIHVzZWQgYWNyb3NzIHRoZSBwb2x5ZmlsbFxyXG4gICAgICovXHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIFNoYWRvdyBSb290IGNvbnN0cnVjdG9yIGV4aXN0cyB0byBtYWtlIGZ1cnRoZXIgY2hlY2tzIHNpbXBsZXJcclxuICAgIHZhciBzaGFkb3dSb290RXhpc3RzID0gdHlwZW9mIFNoYWRvd1Jvb3QgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgXHJcbiAgICAvLyBMYXN0IHNhdmVkIHNjcm9sbCBwb3NpdGlvblxyXG4gICAgdmFyIHNjcm9sbCA9IHtcclxuICAgICAgICB0b3A6IG51bGwsXHJcbiAgICAgICAgbGVmdDogbnVsbFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gQXJyYXkgb2YgY3JlYXRlZCBTdGlja3kgaW5zdGFuY2VzXHJcbiAgICB2YXIgc3RpY2tpZXMgPSBbXTtcclxuICAgIFxyXG4gICAgLypcclxuICAgICAqIDMuIFV0aWxpdHkgZnVuY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXRPYmosIHNvdXJjZU9iamVjdCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2VPYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmpba2V5XSA9IHNvdXJjZU9iamVjdFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBwYXJzZU51bWVyaWModmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKSB8fCAwO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXREb2NPZmZzZXRUb3Aobm9kZSkge1xyXG4gICAgICAgIHZhciBkb2NPZmZzZXRUb3AgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgZG9jT2Zmc2V0VG9wICs9IG5vZGUub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIGRvY09mZnNldFRvcDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLypcclxuICAgICAqIDQuIFN0aWNreSBjbGFzc1xyXG4gICAgICovXHJcbiAgICBcclxuICAgIHZhciBTdGlja3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU3RpY2t5KG5vZGUpIHtcclxuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XHJcbiAgICBcclxuICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIEhUTUxFbGVtZW50Jyk7XHJcbiAgICAgICAgICAgIGlmIChzdGlja2llcy5zb21lKGZ1bmN0aW9uIChzdGlja3kpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGlja3kuX25vZGUgPT09IG5vZGU7XHJcbiAgICAgICAgICAgIH0pKSB0aHJvdyBuZXcgRXJyb3IoJ1N0aWNreWZpbGwgaXMgYWxyZWFkeSBhcHBsaWVkIHRvIHRoaXMgbm9kZScpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGlja3lNb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICAgICAgc3RpY2tpZXMucHVzaCh0aGlzKTtcclxuICAgIFxyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBfY3JlYXRlQ2xhc3MoU3RpY2t5LCBbe1xyXG4gICAgICAgICAgICBrZXk6ICdyZWZyZXNoJyxcclxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VwcHVrdSB8fCB0aGlzLl9yZW1vdmVkKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB0aGlzLl9kZWFjdGl2YXRlKCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIDEuIFNhdmUgbm9kZSBjb21wdXRlZCBwcm9wc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVDb21wdXRlZFByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogbm9kZUNvbXB1dGVkU3R5bGUudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vZGVDb21wdXRlZFN0eWxlLmRpc3BsYXksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBub2RlQ29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiBub2RlQ29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogbm9kZUNvbXB1dGVkU3R5bGUubWFyZ2luTGVmdCxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogbm9kZUNvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzRmxvYXQ6IG5vZGVDb21wdXRlZFN0eWxlLmNzc0Zsb2F0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogMi4gQ2hlY2sgaWYgdGhlIG5vZGUgY2FuIGJlIGFjdGl2YXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdChub2RlQ29tcHV0ZWRQcm9wcy50b3ApKSB8fCBub2RlQ29tcHV0ZWRQcm9wcy5kaXNwbGF5ID09ICd0YWJsZS1jZWxsJyB8fCBub2RlQ29tcHV0ZWRQcm9wcy5kaXNwbGF5ID09ICdub25lJykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogMy4gR2V0IG5lY2Vzc2FyeSBub2RlIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHNoYWRvd1Jvb3RFeGlzdHMgJiYgcmVmZXJlbmNlTm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByZWZlcmVuY2VOb2RlLmhvc3QgOiByZWZlcmVuY2VOb2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVXaW5PZmZzZXQgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFdpbk9mZnNldCA9IHBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBwYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0OiBwYXJlbnROb2RlLm9mZnNldEhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldFRvV2luZG93ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGVXaW5PZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gbm9kZVdpbk9mZnNldC5yaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldFRvUGFyZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogbm9kZVdpbk9mZnNldC50b3AgLSBwYXJlbnRXaW5PZmZzZXQudG9wIC0gcGFyc2VOdW1lcmljKHBhcmVudENvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGVXaW5PZmZzZXQubGVmdCAtIHBhcmVudFdpbk9mZnNldC5sZWZ0IC0gcGFyc2VOdW1lcmljKHBhcmVudENvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogLW5vZGVXaW5PZmZzZXQucmlnaHQgKyBwYXJlbnRXaW5PZmZzZXQucmlnaHQgLSBwYXJzZU51bWVyaWMocGFyZW50Q29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5zdHlsZS5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IG5vZGUuc3R5bGUudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogbm9kZS5zdHlsZS5ib3R0b20sXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbm9kZS5zdHlsZS5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBub2RlLnN0eWxlLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLnN0eWxlLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogbm9kZS5zdHlsZS5tYXJnaW5Ub3AsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogbm9kZS5zdHlsZS5tYXJnaW5MZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBub2RlLnN0eWxlLm1hcmdpblJpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVRvcFZhbHVlID0gcGFyc2VOdW1lcmljKG5vZGVDb21wdXRlZFByb3BzLnRvcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saW1pdHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGVXaW5PZmZzZXQudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gbm9kZVRvcFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcGFyZW50V2luT2Zmc2V0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCArIHBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gcGFyc2VOdW1lcmljKHBhcmVudENvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIC0gbm9kZS5vZmZzZXRIZWlnaHQgLSBub2RlVG9wVmFsdWUgLSBwYXJzZU51bWVyaWMobm9kZUNvbXB1dGVkUHJvcHMubWFyZ2luQm90dG9tKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIDQuIEVuc3VyZSB0aGF0IHRoZSBub2RlIHdpbGwgYmUgcG9zaXRpb25lZCByZWxhdGl2ZWx5IHRvIHRoZSBwYXJlbnQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UG9zaXRpb24gPSBwYXJlbnRDb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UG9zaXRpb24gIT0gJ2Fic29sdXRlJyAmJiBwYXJlbnRQb3NpdGlvbiAhPSAncmVsYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiA1LiBSZWNhbGMgbm9kZSBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgICAqICAgIEl04oCZcyBpbXBvcnRhbnQgdG8gZG8gdGhpcyBiZWZvcmUgY2xvbmUgaW5qZWN0aW9uIHRvIGF2b2lkIHNjcm9sbGluZyBidWcgaW4gQ2hyb21lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNhbGNQb3NpdGlvbigpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogNi4gQ3JlYXRlIGEgY2xvbmVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5fY2xvbmUgPSB7fTtcclxuICAgICAgICAgICAgICAgIGNsb25lLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGVzIHRvIHRoZSBjbG9uZVxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKGNsb25lLm5vZGUuc3R5bGUsIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVdpbk9mZnNldC5yaWdodCAtIG5vZGVXaW5PZmZzZXQubGVmdCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlV2luT2Zmc2V0LmJvdHRvbSAtIG5vZGVXaW5PZmZzZXQudG9wICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IG5vZGVDb21wdXRlZFByb3BzLm1hcmdpblRvcCxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IG5vZGVDb21wdXRlZFByb3BzLm1hcmdpbkJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBub2RlQ29tcHV0ZWRQcm9wcy5tYXJnaW5MZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBub2RlQ29tcHV0ZWRQcm9wcy5tYXJnaW5SaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBjc3NGbG9hdDogbm9kZUNvbXB1dGVkUHJvcHMuY3NzRmxvYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyU3BhY2luZzogMCxcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzFlbScsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdzdGF0aWMnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUubm9kZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5kb2NPZmZzZXRUb3AgPSBnZXREb2NPZmZzZXRUb3AoY2xvbmUubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIGtleTogJ19yZWNhbGNQb3NpdGlvbicsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVjYWxjUG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9yZW1vdmVkKSByZXR1cm47XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHZhciBzdGlja3lNb2RlID0gc2Nyb2xsLnRvcCA8PSB0aGlzLl9saW1pdHMuc3RhcnQgPyAnc3RhcnQnIDogc2Nyb2xsLnRvcCA+PSB0aGlzLl9saW1pdHMuZW5kID8gJ2VuZCcgOiAnbWlkZGxlJztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0aWNreU1vZGUgPT0gc3RpY2t5TW9kZSkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0aWNreU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLl9ub2RlLnN0eWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuX29mZnNldFRvUGFyZW50LmxlZnQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuX29mZnNldFRvUGFyZW50LnJpZ2h0ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fb2Zmc2V0VG9QYXJlbnQudG9wICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQodGhpcy5fbm9kZS5zdHlsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9vZmZzZXRUb1dpbmRvdy5sZWZ0ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLl9vZmZzZXRUb1dpbmRvdy5yaWdodCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX3N0eWxlcy50b3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMuX25vZGUuc3R5bGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5fb2Zmc2V0VG9QYXJlbnQubGVmdCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5fb2Zmc2V0VG9QYXJlbnQucmlnaHQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RpY2t5TW9kZSA9IHN0aWNreU1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIGtleTogJ19mYXN0Q2hlY2snLFxyXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zhc3RDaGVjaygpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlIHx8IHRoaXMuX3JlbW92ZWQpIHJldHVybjtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGdldERvY09mZnNldFRvcCh0aGlzLl9jbG9uZS5ub2RlKSAtIHRoaXMuX2Nsb25lLmRvY09mZnNldFRvcCkgPiAxIHx8IE1hdGguYWJzKHRoaXMuX3BhcmVudC5ub2RlLm9mZnNldEhlaWdodCAtIHRoaXMuX3BhcmVudC5vZmZzZXRIZWlnaHQpID4gMSkgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIGtleTogJ19kZWFjdGl2YXRlJyxcclxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fcmVtb3ZlZCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9uZS5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2xvbmUubm9kZSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2xvbmU7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLl9ub2RlLnN0eWxlLCB0aGlzLl9zdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0eWxlcztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBlbGVtZW504oCZcyBwYXJlbnQgbm9kZSBpcyB1c2VkIGJ5IG90aGVyIHN0aWNraWVzLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCByZXN0b3JlIHBhcmVudCBub2Rl4oCZcyBzdHlsZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0aWNraWVzLnNvbWUoZnVuY3Rpb24gKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGlja3kgIT09IF90aGlzICYmIHN0aWNreS5fcGFyZW50ICYmIHN0aWNreS5fcGFyZW50Lm5vZGUgPT09IF90aGlzLl9wYXJlbnQubm9kZTtcclxuICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMuX3BhcmVudC5ub2RlLnN0eWxlLCB0aGlzLl9wYXJlbnQuc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnQ7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0aWNreU1vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vZmZzZXRUb1dpbmRvdztcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vZmZzZXRUb1BhcmVudDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saW1pdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIGtleTogJ3JlbW92ZScsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZSgpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzdGlja2llcy5zb21lKGZ1bmN0aW9uIChzdGlja3ksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0aWNreS5fbm9kZSA9PT0gX3RoaXMyLl9ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0aWNraWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1dKTtcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBTdGlja3k7XHJcbiAgICB9KCk7XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgKiA1LiBTdGlja3lmaWxsIEFQSVxyXG4gICAgICovXHJcbiAgICBcclxuICAgIFxyXG4gICAgdmFyIFN0aWNreWZpbGwgPSB7XHJcbiAgICAgICAgc3RpY2tpZXM6IHN0aWNraWVzLFxyXG4gICAgICAgIFN0aWNreTogU3RpY2t5LFxyXG4gICAgXHJcbiAgICAgICAgYWRkT25lOiBmdW5jdGlvbiBhZGRPbmUobm9kZSkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGl04oCZcyBhIG5vZGVcclxuICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF5YmUgaXTigJlzIGEgbm9kZSBsaXN0IG9mIHNvbWUgc29ydD9cclxuICAgICAgICAgICAgICAgIC8vIFRha2UgZmlyc3Qgbm9kZSBmcm9tIHRoZSBsaXN0IHRoZW5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxlbmd0aCAmJiBub2RlWzBdKSBub2RlID0gbm9kZVswXTtlbHNlIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIFN0aWNreWZpbGwgaXMgYWxyZWFkeSBhcHBsaWVkIHRvIHRoZSBub2RlXHJcbiAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gZXhpc3Rpbmcgc3RpY2t5XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RpY2tpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGlja2llc1tpXS5fbm9kZSA9PT0gbm9kZSkgcmV0dXJuIHN0aWNraWVzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gbmV3IHN0aWNreVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0aWNreShub2RlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKG5vZGVMaXN0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIGl04oCZcyBhIG5vZGUgbWFrZSBhbiBhcnJheSBvZiBvbmUgbm9kZVxyXG4gICAgICAgICAgICBpZiAobm9kZUxpc3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgbm9kZUxpc3QgPSBbbm9kZUxpc3RdO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJndW1lbnQgaXMgYW4gaXRlcmFibGUgb2Ygc29tZSBzb3J0XHJcbiAgICAgICAgICAgIGlmICghbm9kZUxpc3QubGVuZ3RoKSByZXR1cm47XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQWRkIGV2ZXJ5IGVsZW1lbnQgYXMgYSBzdGlja3kgYW5kIHJldHVybiBhbiBhcnJheSBvZiBjcmVhdGVkIFN0aWNreSBpbnN0YW5jZXNcclxuICAgICAgICAgICAgdmFyIGFkZGVkU3RpY2tpZXMgPSBbXTtcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVMaXN0W2ldO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdOKAmXMgbm90IGFuIEhUTUxFbGVtZW50IOKAkyBjcmVhdGUgYW4gZW1wdHkgZWxlbWVudCB0byBwcmVzZXJ2ZSAxLXRvLTFcclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlbGF0aW9uIHdpdGggaW5wdXQgbGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkU3RpY2tpZXMucHVzaCh2b2lkIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBTdGlja3lmaWxsIGlzIGFscmVhZHkgYXBwbGllZCB0byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIGV4aXN0aW5nIHN0aWNreVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0aWNraWVzLnNvbWUoZnVuY3Rpb24gKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGlja3kuX25vZGUgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRTdGlja2llcy5wdXNoKHN0aWNreSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKSByZXR1cm4gJ2NvbnRpbnVlJztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgbmV3IHN0aWNreVxyXG4gICAgICAgICAgICAgICAgYWRkZWRTdGlja2llcy5wdXNoKG5ldyBTdGlja3kobm9kZSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIHJldHVybiBhZGRlZFN0aWNraWVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVmcmVzaEFsbDogZnVuY3Rpb24gcmVmcmVzaEFsbCgpIHtcclxuICAgICAgICAgICAgc3RpY2tpZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RpY2t5LnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVPbmU6IGZ1bmN0aW9uIHJlbW92ZU9uZShub2RlKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgaXTigJlzIGEgbm9kZVxyXG4gICAgICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXliZSBpdOKAmXMgYSBub2RlIGxpc3Qgb2Ygc29tZSBzb3J0P1xyXG4gICAgICAgICAgICAgICAgLy8gVGFrZSBmaXJzdCBub2RlIGZyb20gdGhlIGxpc3QgdGhlblxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGVuZ3RoICYmIG5vZGVbMF0pIG5vZGUgPSBub2RlWzBdO2Vsc2UgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGlja2llcyBib3VuZCB0byB0aGUgbm9kZXMgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgc3RpY2tpZXMuc29tZShmdW5jdGlvbiAoc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RpY2t5Ll9ub2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGVMaXN0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIGl04oCZcyBhIG5vZGUgbWFrZSBhbiBhcnJheSBvZiBvbmUgbm9kZVxyXG4gICAgICAgICAgICBpZiAobm9kZUxpc3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgbm9kZUxpc3QgPSBbbm9kZUxpc3RdO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJndW1lbnQgaXMgYW4gaXRlcmFibGUgb2Ygc29tZSBzb3J0XHJcbiAgICAgICAgICAgIGlmICghbm9kZUxpc3QubGVuZ3RoKSByZXR1cm47XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGlja2llcyBib3VuZCB0byB0aGUgbm9kZXMgaW4gdGhlIGxpc3RcclxuICAgIFxyXG4gICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZUxpc3RbaV07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHN0aWNraWVzLnNvbWUoZnVuY3Rpb24gKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGlja3kuX25vZGUgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RpY2t5LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBfbG9vcDIoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xyXG4gICAgICAgICAgICB3aGlsZSAoc3RpY2tpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGlja2llc1swXS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgKiA2LiBTZXR1cCBldmVudHMgKHVubGVzcyB0aGUgcG9seWZpbGwgd2FzIGRpc2FibGVkKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIC8vIFdhdGNoIGZvciBzY3JvbGwgcG9zaXRpb24gY2hhbmdlcyBhbmQgdHJpZ2dlciByZWNhbGMvcmVmcmVzaCBpZiBuZWVkZWRcclxuICAgICAgICBmdW5jdGlvbiBjaGVja1Njcm9sbCgpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wYWdlWE9mZnNldCAhPSBzY3JvbGwubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsLnRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNjcm9sbC5sZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBTdGlja3lmaWxsLnJlZnJlc2hBbGwoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cucGFnZVlPZmZzZXQgIT0gc2Nyb2xsLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsLnRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNjcm9sbC5sZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyByZWNhbGMgcG9zaXRpb24gZm9yIGFsbCBzdGlja2llc1xyXG4gICAgICAgICAgICAgICAgc3RpY2tpZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0aWNreS5fcmVjYWxjUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgY2hlY2tTY3JvbGwoKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgY2hlY2tTY3JvbGwpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gV2F0Y2ggZm9yIHdpbmRvdyByZXNpemVzIGFuZCBkZXZpY2Ugb3JpZW50YXRpb24gY2hhbmdlcyBhbmQgdHJpZ2dlciByZWZyZXNoXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIFN0aWNreWZpbGwucmVmcmVzaEFsbCk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgU3RpY2t5ZmlsbC5yZWZyZXNoQWxsKTtcclxuICAgIFxyXG4gICAgICAgIC8vRmFzdCBkaXJ0eSBjaGVjayBmb3IgbGF5b3V0IGNoYW5nZXMgZXZlcnkgNTAwbXNcclxuICAgICAgICB2YXIgZmFzdENoZWNrVGltZXIgPSB2b2lkIDA7XHJcbiAgICBcclxuICAgICAgICBmdW5jdGlvbiBzdGFydEZhc3RDaGVja1RpbWVyKCkge1xyXG4gICAgICAgICAgICBmYXN0Q2hlY2tUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN0aWNraWVzLmZvckVhY2goZnVuY3Rpb24gKHN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGlja3kuX2Zhc3RDaGVjaygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgZnVuY3Rpb24gc3RvcEZhc3RDaGVja1RpbWVyKCkge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKGZhc3RDaGVja1RpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICB2YXIgZG9jSGlkZGVuS2V5ID0gdm9pZCAwO1xyXG4gICAgICAgIHZhciB2aXNpYmlsaXR5Q2hhbmdlRXZlbnROYW1lID0gdm9pZCAwO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKCdoaWRkZW4nIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY0hpZGRlbktleSA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlRXZlbnROYW1lID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoJ3dlYmtpdEhpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jSGlkZGVuS2V5ID0gJ3dlYmtpdEhpZGRlbic7XHJcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2VFdmVudE5hbWUgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYgKHZpc2liaWxpdHlDaGFuZ2VFdmVudE5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFtkb2NIaWRkZW5LZXldKSBzdGFydEZhc3RDaGVja1RpbWVyKCk7XHJcbiAgICBcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlRXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRbZG9jSGlkZGVuS2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGYXN0Q2hlY2tUaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEZhc3RDaGVja1RpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBzdGFydEZhc3RDaGVja1RpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghc2VwcHVrdSkgaW5pdCgpO1xyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgICogNy4gRXhwb3NlIFN0aWNreWZpbGxcclxuICAgICAqL1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFN0aWNreWZpbGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5TdGlja3lmaWxsID0gU3RpY2t5ZmlsbDtcclxuICAgIH1cclxuICAgIFxyXG59KSh3aW5kb3csIGRvY3VtZW50KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e){ true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(function(){var e=function(e){function n(){g=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){return setTimeout(e,1e3/60)}}function t(){if(h&&"number"==typeof h){var e=Math.min(Math.max(0,h),1);return q-e*q}return q}function i(){var e=document.documentElement.clientHeight,n=window.innerHeight||0;q=Math.max(e,n)}function o(){y=!1;var e=t();A=A.filter(function(n){var t=n.getBoundingClientRect(),i=t.top,o=i<e;if(o&&!n.__enter_view){if(m(n),_)return!1}else!o&&n.__enter_view&&w&&w(n);return n.__enter_view=o,!0}),A.length||window.removeEventListener("scroll",r,!0)}function r(){y||(y=!0,g(o))}function u(){i(),o()}function f(e){for(var n=e.length,t=[],i=0;i<n;i+=1)t.push(e[i]);return t}function c(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document;return"string"==typeof e?f(n.querySelectorAll(e)):e instanceof NodeList?f(e):e instanceof Array?e:void 0}function d(){A=c(l)}function a(){window.addEventListener("resize",u,!0),window.addEventListener("scroll",r,!0),u()}function s(){var e=l&&m;e||console.error("must set selector and enter options"),n(),d(),a(),o()}var l=e.selector,m=e.enter,w=e.exit,v=e.offset,h=void 0===v?0:v,p=e.once,_=void 0!==p&&p,g=null,y=!1,A=[],q=0;s()};return e});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRlci12aWV3L2VudGVyLXZpZXcubWluLmpzPzM4ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7IWZ1bmN0aW9uKGUpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZSgpOndpbmRvdy5lbnRlclZpZXc9ZS5jYWxsKHRoaXMpfShmdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oKXtnPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSl7cmV0dXJuIHNldFRpbWVvdXQoZSwxZTMvNjApfX1mdW5jdGlvbiB0KCl7aWYoaCYmXCJudW1iZXJcIj09dHlwZW9mIGgpe3ZhciBlPU1hdGgubWluKE1hdGgubWF4KDAsaCksMSk7cmV0dXJuIHEtZSpxfXJldHVybiBxfWZ1bmN0aW9uIGkoKXt2YXIgZT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LG49d2luZG93LmlubmVySGVpZ2h0fHwwO3E9TWF0aC5tYXgoZSxuKX1mdW5jdGlvbiBvKCl7eT0hMTt2YXIgZT10KCk7QT1BLmZpbHRlcihmdW5jdGlvbihuKXt2YXIgdD1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9dC50b3Asbz1pPGU7aWYobyYmIW4uX19lbnRlcl92aWV3KXtpZihtKG4pLF8pcmV0dXJuITF9ZWxzZSFvJiZuLl9fZW50ZXJfdmlldyYmdyYmdyhuKTtyZXR1cm4gbi5fX2VudGVyX3ZpZXc9bywhMH0pLEEubGVuZ3RofHx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHIsITApfWZ1bmN0aW9uIHIoKXt5fHwoeT0hMCxnKG8pKX1mdW5jdGlvbiB1KCl7aSgpLG8oKX1mdW5jdGlvbiBmKGUpe2Zvcih2YXIgbj1lLmxlbmd0aCx0PVtdLGk9MDtpPG47aSs9MSl0LnB1c2goZVtpXSk7cmV0dXJuIHR9ZnVuY3Rpb24gYyhlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZG9jdW1lbnQ7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZihuLnF1ZXJ5U2VsZWN0b3JBbGwoZSkpOmUgaW5zdGFuY2VvZiBOb2RlTGlzdD9mKGUpOmUgaW5zdGFuY2VvZiBBcnJheT9lOnZvaWQgMH1mdW5jdGlvbiBkKCl7QT1jKGwpfWZ1bmN0aW9uIGEoKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHUsITApLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsciwhMCksdSgpfWZ1bmN0aW9uIHMoKXt2YXIgZT1sJiZtO2V8fGNvbnNvbGUuZXJyb3IoXCJtdXN0IHNldCBzZWxlY3RvciBhbmQgZW50ZXIgb3B0aW9uc1wiKSxuKCksZCgpLGEoKSxvKCl9dmFyIGw9ZS5zZWxlY3RvcixtPWUuZW50ZXIsdz1lLmV4aXQsdj1lLm9mZnNldCxoPXZvaWQgMD09PXY/MDp2LHA9ZS5vbmNlLF89dm9pZCAwIT09cCYmcCxnPW51bGwseT0hMSxBPVtdLHE9MDtzKCl9O3JldHVybiBlfSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// D3 is included by globally by default\nvar Graphic = function Graphic() {\n    var width = window.innerWidth,\n        height = window.innerHeight;\n    var scene = new THREE.Scene(),\n        sceneAtmosphere = new THREE.Scene();\n    var camera = new THREE.OrthographicCamera(width / -1, width / 1, height / 1, height / -1, 0.01, 15000);\n    var self = this;\n\n    // var helper = new THREE.CameraHelper( camera );\n    // scene.add( helper );\n    var controls = void 0,\n        raycaster = void 0,\n        mouse = { x: 0, y: 0 },\n        intersects = void 0,\n        INTERSECTED = void 0;\n    var AU = 27,\n        sunSize = 348.15;\n    var renderer = new THREE.WebGLRenderer();\n    //const stats = new Stats(), gui = new dat.GUI();\n    var category = ['Population', 'GDP', 'Literacy'];\n\n    var planetData = [{ name: 'Mercury', size: 1.2, orbitRadius: sunSize + AU * 0.4, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.8, rotateSpeed: 0.05, img: './assets/model/mercury.jpeg' }, { name: 'Venus', size: 3, orbitRadius: sunSize + AU * 0.7, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.7, rotateSpeed: 0.05, img: './assets/model/venus.jpeg' }, { name: 'Earth', size: 3, orbitRadius: sunSize + AU, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.6, rotateSpeed: 0.05, img: './assets/model/earth2.jpg' }, { name: 'Mars', size: 1.6, orbitRadius: sunSize + AU * 1.5, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.48, rotateSpeed: 0.05, img: './assets/model/mars.jpeg' }, { name: 'Jupiter', size: 34.99, orbitRadius: sunSize + AU * 5.2, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.22, rotateSpeed: 0.05, img: './assets/model/jupiter.jpeg' }, { name: 'Saturn', size: 29.1, orbitRadius: sunSize + AU * 9.5, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.18, rotateSpeed: 0.05, img: './assets/model/saturn.png' }, { name: 'Uranus', size: 12.7, orbitRadius: sunSize + AU * 19.2, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.13, rotateSpeed: 0.05, img: './assets/model/uranus.jpeg' }, { name: 'Neptune', size: 12.3, orbitRadius: sunSize + AU * 30.1, orbitAngle: getRandomArbitrary(360, 360), orbitSpeed: 0.1, rotateSpeed: 0.05, img: './assets/model/neptune.jpeg' }, { name: 'Sun', size: sunSize, orbitRadius: 0, orbitAngle: 0, orbitSpeed: 0.1, rotateSpeed: 0.05, img: './assets/model/sun.jpg' }];\n    var Shaders = {\n        'earth': {\n            uniforms: {},\n            vertexShader: ['varying vec3 vNormal;', 'void main() {', 'vNormal = normalize( normalMatrix * normal );', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n            fragmentShader: ['varying vec3 vNormal;', 'void main() {', 'float intensity = pow( 0.8 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );', 'gl_FragColor = vec4( 0.074, 0.996, 0.992, 1.0 ) * intensity;', '}'].join('\\n')\n        },\n        'atmosphere': {\n            uniforms: {},\n            vertexShader: ['varying vec3 vNormal;', 'void main() {', 'vNormal = normalize( normalMatrix * normal );', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n            fragmentShader: ['varying vec3 vNormal;', 'void main() {', 'float intensity = pow( 0.8 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );', 'gl_FragColor = vec4( 0.996, 0.544, 0.092, 1.0 ) * intensity;', '}'].join('\\n')\n        }\n    };\n    var textMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });\n    var mercuryText = new THREE.Mesh();\n    var venusText = new THREE.Mesh();\n    var marsText = new THREE.Mesh();\n    var earthText = new THREE.Mesh();\n    var jupiterText = new THREE.Mesh();\n    var saturnText = new THREE.Mesh();\n    var uranusText = new THREE.Mesh();\n    var neptuneText = new THREE.Mesh();\n    var mercury = createStars(planetData[0].size, planetData[0].img, 10, \"Mercury\");\n    var venus = createStars(planetData[1].size, planetData[1].img, 25, \"Venus\");\n    var earth = createStars(planetData[2].size, planetData[2].img, 40, \"Earth\");\n    var mars = createStars(planetData[3].size, planetData[3].img, 10, \"Mars\");\n    var jupiter = createStars(planetData[4].size, planetData[4].img, 10, \"Jupiter\");\n    var saturn = createStars(planetData[5].size, planetData[5].img, 10, \"Saturn\");\n    var uranus = createStars(planetData[6].size, planetData[6].img, 10, \"Uranus\");\n    var neptune = createStars(planetData[7].size, planetData[7].img, 10, \"Neptune\");\n    var sun = createStars(planetData[8].size, planetData[8].img, 50, \"Sun\");\n    //sun glow\n    createGlow(sun, new THREE.SphereGeometry(sunSize, 50, 50), Shaders['atmosphere'], 1.02);\n    //createGlow(earth, new THREE.SphereGeometry(3, 40, 40), Shaders['earth'], 1.03); //earthGlow\n\n    var allText = [];\n    var earthDataGeo = void 0,\n        earthDataMesh = void 0;\n    var baseGeo = new THREE.Geometry();\n    var baseMesh = void 0;\n    var textSize = 3;\n    var tooltipGeo = void 0,\n        tooltipMesh = void 0;\n    var preSelected = { 'Country': '' };\n    var tooltip = document.getElementsByClassName('yw_tooltip')[0];\n\n    function init() {\n\n        scene.add(camera);\n        scene.add(new THREE.AmbientLight(0xffffff));\n\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.getElementById('solar-canvas').appendChild(renderer.domElement); //A canvas is automatically created by the renderer in the constructor.\n\n        // controls, camera\n        controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableZoom = false;\n        controls.target.set(375, 0, 0);\n        camera.position.set(375, 0, 2000);\n        // camera.position.set( 200, 18, 2000 );\n        controls.update(); //must be called after any manual changes to the camera's transform\n\n        raycaster = new THREE.Raycaster();\n\n        //document.getElementById('solar-canvas').appendChild( stats.dom );\n\n        //create saturn ring\n        var saturnSize = 29.1;\n        var saturnRingMaterial = new THREE.MeshLambertMaterial({\n            map: THREE.ImageUtils.loadTexture('./assets/model/saturnRing.png'),\n            flatShading: THREE.SmoothShading,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        var saturnRingStart = saturnSize + 3.3;\n        var saturnRingEnd = saturnSize + 60;\n        var saturnRing = new THREE.Mesh(new THREE.RingGeometry(saturnRingStart, saturnRingEnd, 30), saturnRingMaterial);\n        saturn.add(saturnRing);\n        saturnRing.rotation.x = 90 * Math.PI / 180;\n\n        new THREE.FontLoader().load('./assets/model/helvetiker_regular.typeface.json', function (font) {\n            mercuryText = createText(mercury, mercuryText, planetData[0].name, font);\n            venusText = createText(venus, venusText, planetData[1].name, font);\n            earthText = createText(earth, earthText, planetData[2].name, font);\n            marsText = createText(mars, marsText, planetData[3].name, font);\n            saturnText = createText(saturn, saturnText, planetData[4].name, font);\n            jupiterText = createText(jupiter, jupiterText, planetData[5].name, font);\n            uranusText = createText(uranus, uranusText, planetData[6].name, font);\n            neptuneText = createText(neptune, neptuneText, planetData[7].name, font);\n            allText = [mercuryText, venusText, earthText, marsText, saturnText, jupiterText, uranusText, neptuneText];\n        });\n        //cube\n        var earthCubeSize = 10;\n        earthDataGeo = new THREE.BoxGeometry(earthCubeSize, earthCubeSize, earthCubeSize, 1);\n        earthDataGeo.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));\n        earthDataMesh = new THREE.Mesh(earthDataGeo);\n\n        //helper\n        // gui.add(camera.position, 'x', -2000, 10000);\n        // gui.add(camera.position, 'y', -2000, 10000);\n        // gui.add(camera.position, 'z', -2000, 10000);\n\n        addData();\n\n        //tooltip\n\n        tooltipGeo = new THREE.BoxGeometry(10, 10, 10, 1);\n        tooltipGeo.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));\n        var tooltipMat = new THREE.MeshBasicMaterial({ color: 0xffffff });\n        tooltipMesh = new THREE.Mesh(tooltipGeo, tooltipMat);\n        tooltipMesh.name = 'tooltip_mesh';\n        scene.add(tooltipMesh);\n    }\n\n    function createText(planet, planetText, text, font) {\n        var textGeometry = new THREE.TextGeometry(text, {\n            font: font,\n            size: textSize,\n            bevelEnabled: false,\n            height: 1\n        });\n        planetText = new THREE.Mesh(textGeometry, textMaterial);\n        planet.add(planetText);\n        return planetText;\n    }\n    function getMax(data, attr) {\n        return data.reduce(function (max, p) {\n            return p[attr] > max ? p[attr] : max;\n        }, data[0][attr]);\n    }\n    function getRandomArbitrary(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    function planetRotate(planet, text, id, yTextPos, xTextPos, textSize) {\n        if (!yTextPos) yTextPos = 0;\n        var data = planetData[id];\n        //let radians = planetData[id].orbitAngle * Math.PI / 180;\n        planet.position.x = planetData[id].orbitRadius;\n        planet.position.z = 0;\n        planet.position.y = 0;\n        //planet.rotation.y += planetData[id].rotateSpeed;\n        text.position.x = planetData[id].size + xTextPos / camera.zoom;\n        text.position.y = yTextPos;\n        text.position.z = 0;\n        text.scale.set(textSize, textSize, textSize);\n        // text.scale()\n        text.needsUpdate = true;\n    }\n\n    function resize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix(); //Updates the camera projection matrix. Must be called after any change of parameters.\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    function createStars(size, img, segment, name) {\n        var textureLoader = new THREE.TextureLoader();\n        var material = new THREE.MeshLambertMaterial({\n            map: textureLoader.load(img),\n            flatShading: THREE.SmoothShading\n        });\n        var planet = new THREE.Mesh(new THREE.SphereGeometry(size, segment, segment), material);\n        planet.name = name;\n        scene.add(planet);\n        return planet;\n    }\n\n    function addData() {\n        // Promise\n        var requestData = request('GET', './assets/model/allCountries.json');\n        // call our promise\n        requestData.then(processData).then(addToEarth).then(function (fulfilled) {\n            return console.log(fulfilled);\n        }).catch(function (error) {\n            return console.log(error.message);\n        });\n    }\n\n    function request(method, url) {\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(method, url);\n            xhr.onload = resolve;\n            xhr.onerror = reject;\n            xhr.send();\n        });\n    }\n\n    function processData(data) {\n        return new Promise(function (resolve, reject) {\n            var newData = JSON.parse(data.target.responseText);\n            console.log('process data');\n            newData.forEach(function (t) {\n                addPoint(+t.Latitude, +t.Longitude, 0, getColor(+t['Population']), baseGeo);\n            });\n            self.data = newData;\n            baseGeo.morphTargets.push({ 'name': 'target-' + 0, vertices: baseGeo.vertices });\n\n            var _loop = function _loop(i) {\n                var attr = category[i];\n                var maxInAttr = getMax(newData, attr);\n                console.log(attr, maxInAttr);\n                var subGeo = new THREE.Geometry();\n                newData.forEach(function (d) {\n                    var size = +d[attr] / maxInAttr / 2; // linearScale\n                    addPoint(+d.Latitude, +d.Longitude, size, getColor(size), subGeo);\n                });\n                baseGeo.morphTargets.push({ 'name': 'target-' + (i + 1), vertices: subGeo.vertices });\n            };\n\n            for (var i = 0; i < 3; i++) {\n                _loop(i);\n            }\n            resolve();\n        });\n    }\n    function addToEarth() {\n        baseMesh = new THREE.Mesh(baseGeo, new THREE.MeshBasicMaterial({\n            color: 0xffff00,\n            vertexColors: THREE.FaceColors,\n            morphTargets: true\n        }));\n        earth.add(baseMesh);\n        console.log(baseMesh);\n        var message = 'added baseMesh';\n        return Promise.resolve(message);\n    }\n\n    function createGlow(planet, geometry, shader, scale) {\n        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n        var material = new THREE.ShaderMaterial({\n\n            uniforms: uniforms,\n            vertexShader: shader.vertexShader,\n            fragmentShader: shader.fragmentShader,\n            side: THREE.BackSide,\n            blending: THREE.AdditiveBlending\n            // transparent: true\n        });\n        var mesh = new THREE.Mesh(geometry, material);\n        mesh.scale.set(scale, scale, scale);\n        mesh.matrixAutoUpdate = false;\n        mesh.updateMatrix();\n        planet.add(mesh); // the glow\n    }\n    // animate();\n    function animate() {\n        var param = Math.sqrt(camera.zoom).toFixed(2);\n        var xTextPos = 30 / param;\n        var newTextSize = textSize / camera.zoom;\n        planetRotate(mercury, mercuryText, 0, -30 / param, xTextPos, newTextSize);\n        planetRotate(venus, venusText, 1, -15 / param, xTextPos, newTextSize);\n        planetRotate(earth, earthText, 2, 0 / param, xTextPos, newTextSize);\n        planetRotate(mars, marsText, 3, 15 / param, xTextPos, newTextSize);\n        planetRotate(jupiter, jupiterText, 4, 30 / param, xTextPos, newTextSize);\n        planetRotate(saturn, saturnText, 5, 30 / param, xTextPos, newTextSize);\n        planetRotate(uranus, uranusText, 6, 10 / param, xTextPos, newTextSize);\n        planetRotate(neptune, neptuneText, 7, 10 / param, xTextPos, newTextSize);\n        camera.updateProjectionMatrix();\n        sun.position.x = 0;\n        sun.position.z = 0;\n        sun.position.y = 0;\n        //stats.update();\n        TWEEN.update();\n        //The code below doesn't work. It cannot get right texts\n        // eightPlanets.forEach(function (planet, id) {\n        //     planetRotate(planet, allText[id], id);\n        // })\n\n        render();\n\n        requestAnimationFrame(animate);\n    }\n\n    function shrinkFonts() {}\n\n    function addPoint(lat, lng, size, color, geo) {\n        var phi = (90 - lat) * Math.PI / 180;\n        var theta = (360 - lng) * Math.PI / 180;\n        var r = 3;\n        earthDataMesh.position.x = r * Math.sin(phi) * Math.cos(theta);\n        earthDataMesh.position.y = r * Math.cos(phi);\n        earthDataMesh.position.z = r * Math.sin(phi) * Math.sin(theta);\n        earthDataMesh.scale.z = -size;\n        earthDataMesh.scale.x = 1 / 400;\n        earthDataMesh.scale.y = 1 / 400;\n        earthDataMesh.lookAt(new THREE.Vector3(0, 0, 0));\n        earthDataMesh.updateMatrix();\n        for (var i = 0; i < earthDataMesh.geometry.faces.length; i++) {\n            earthDataMesh.geometry.faces[i].color = color;\n        }\n        // earthDataMesh.material = material? material : new THREE.MeshBasicMaterial();\n        earthDataMesh.updateMatrix();\n        //console.log(earthDataMesh);\n        geo.merge(earthDataMesh.geometry, earthDataMesh.matrix);\n    }\n\n    function onDocumentMouseMove(event) {\n        event.preventDefault();\n        mouse.x = event.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    }\n\n    function getColor(x) {\n\n        var color = x > 100000000 ? new THREE.Color(\"rgb(255, 130, 0)\") : new THREE.Color(\"rgb(0, 255, 255)\");\n        return color;\n    };\n\n    //TODO: add raycaster to baseMesh\n    function render() {\n        camera.lookAt(earth.position);\n        renderer.render(scene, camera);\n        raycaster.setFromCamera(mouse, camera);\n        if (baseMesh != undefined) {\n            intersects = raycaster.intersectObject(baseMesh);\n            if (intersects.length > 0) {\n                if (INTERSECTED != intersects[0].faceIndex) {\n                    var selectedMesh = intersects[0].object;\n                    INTERSECTED = Math.floor(intersects[0].faceIndex / 12);\n                    showTooltip(INTERSECTED);\n                }\n            } else if (INTERSECTED !== null) {\n                INTERSECTED = null;\n                tooltip.classList.remove(\"active\");\n                // intersects[0].object.geometry.scale(new THREE.Vector3( 1, 1, 1 ));\n            }\n        }\n    }\n\n    this.__defineSetter__('time', function (t) {\n        //console.log('setTime: ', t);\n        // t= 0, 1/3, 2/3\n        //morphTransition(t);\n        this._time = t;\n    });\n\n    this.__defineGetter__('time', function () {\n        return this._time || 0;\n    });\n\n    function showTooltip(selected) {\n        var selectedData = self.data[selected];\n        if (selectedData != undefined && selectedData['Country'] != preSelected['Country']) {\n            console.log(selectedData);\n            tooltip.classList.add(\"active\");\n            console.log(selectedData['Country']);\n            tooltip.innerHTML = '<p><strong>' + selectedData['Country'] + '</strong></br>\\n            Population: ' + addCommas(selectedData['Population']) + '</br>\\n            GDP: ' + addCommas(selectedData['GDP']) + ' $ per capita</br>\\n            Literacy rate: ' + selectedData['Literacy'] + '% </p>';\n        }\n    }\n\n    function addCommas(nStr) {\n        nStr += '';\n        var x = nStr.split('.');\n        var x1 = x[0];\n        var x2 = x.length > 1 ? '.' + x[1] : '';\n        var rgx = /(\\d+)(\\d{3})/;\n        while (rgx.test(x1)) {\n            x1 = x1.replace(rgx, '$1' + ',' + '$2');\n        }\n        return x1 + x2;\n    }\n\n    function getBaseMesh() {\n        if (baseMesh != undefined) {\n            return baseMesh;\n        }\n    }\n\n    function getCamera() {\n        return camera;\n    }\n\n    window.addEventListener('resize', resize);\n    document.addEventListener('mousemove', onDocumentMouseMove, false);\n\n    this.init = init;\n    this.resize = resize;\n    this.animate = animate;\n    this.getCamera = getCamera;\n    this.getBaseMesh = getBaseMesh;\n\n    return this;\n};\n\nexports.default = Graphic;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvZ3JhcGhpYy5qcz8xYzIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEQzIGlzIGluY2x1ZGVkIGJ5IGdsb2JhbGx5IGJ5IGRlZmF1bHRcbnZhciBHcmFwaGljID0gZnVuY3Rpb24oKXtcbiAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCksIHNjZW5lQXRtb3NwaGVyZT0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgbGV0IGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIHdpZHRoIC8gLSAxLCB3aWR0aCAvIDEsIGhlaWdodCAvIDEsIGhlaWdodCAvIC0gMSwgMC4wMSwgMTUwMDAgKTtcbiAgICBjb25zdCBzZWxmPXRoaXM7XG5cbiAgICAvLyB2YXIgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2FtZXJhICk7XG4gICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICBsZXQgY29udHJvbHMsIHJheWNhc3RlciwgbW91c2U9IHsgeDogMCwgeTogMCB9LCBpbnRlcnNlY3RzLCBJTlRFUlNFQ1RFRDtcbiAgICBjb25zdCBBVSA9IDI3LCBzdW5TaXplID0gMzQ4LjE1O1xuICAgIGxldCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgLy9jb25zdCBzdGF0cyA9IG5ldyBTdGF0cygpLCBndWkgPSBuZXcgZGF0LkdVSSgpO1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWyAnUG9wdWxhdGlvbicsICdHRFAnLCAnTGl0ZXJhY3knXTtcblxuICAgIGNvbnN0IHBsYW5ldERhdGEgPVtcbiAgICAgICAge25hbWU6ICdNZXJjdXJ5Jywgc2l6ZTogMS4yLCBvcmJpdFJhZGl1czogc3VuU2l6ZSArIChBVSAqIDAuNCksIG9yYml0QW5nbGU6IGdldFJhbmRvbUFyYml0cmFyeSgzNjAsMzYwKSwgb3JiaXRTcGVlZDogMC44LCByb3RhdGVTcGVlZDogMC4wNSwgaW1nOicuL2Fzc2V0cy9tb2RlbC9tZXJjdXJ5LmpwZWcnfSxcbiAgICAgICAge25hbWU6ICdWZW51cycsIHNpemU6IDMsIG9yYml0UmFkaXVzOiBzdW5TaXplICsgKEFVICogMC43KSwgb3JiaXRBbmdsZTogZ2V0UmFuZG9tQXJiaXRyYXJ5KDM2MCwzNjApLCBvcmJpdFNwZWVkOiAwLjcsIHJvdGF0ZVNwZWVkOiAwLjA1LCBpbWc6Jy4vYXNzZXRzL21vZGVsL3ZlbnVzLmpwZWcnfSxcbiAgICAgICAge25hbWU6ICdFYXJ0aCcsIHNpemU6IDMsIG9yYml0UmFkaXVzOiBzdW5TaXplICsgQVUsIG9yYml0QW5nbGU6IGdldFJhbmRvbUFyYml0cmFyeSgzNjAsMzYwKSwgb3JiaXRTcGVlZDogMC42LCByb3RhdGVTcGVlZDogMC4wNSwgaW1nOicuL2Fzc2V0cy9tb2RlbC9lYXJ0aDIuanBnJ30sXG4gICAgICAgIHtuYW1lOiAnTWFycycsIHNpemU6IDEuNiwgb3JiaXRSYWRpdXM6IHN1blNpemUgKyAoQVUgKiAxLjUpLCBvcmJpdEFuZ2xlOiBnZXRSYW5kb21BcmJpdHJhcnkoMzYwLDM2MCksIG9yYml0U3BlZWQ6IDAuNDgsIHJvdGF0ZVNwZWVkOiAwLjA1LCBpbWc6Jy4vYXNzZXRzL21vZGVsL21hcnMuanBlZyd9LFxuICAgICAgICB7bmFtZTogJ0p1cGl0ZXInLCBzaXplOiAzNC45OSwgb3JiaXRSYWRpdXM6IHN1blNpemUgKyAoQVUgKiA1LjIpLCBvcmJpdEFuZ2xlOiBnZXRSYW5kb21BcmJpdHJhcnkoMzYwLDM2MCksIG9yYml0U3BlZWQ6IDAuMjIsIHJvdGF0ZVNwZWVkOiAwLjA1LCBpbWc6Jy4vYXNzZXRzL21vZGVsL2p1cGl0ZXIuanBlZyd9LFxuICAgICAgICB7bmFtZTogJ1NhdHVybicsIHNpemU6IDI5LjEsIG9yYml0UmFkaXVzOiBzdW5TaXplICsgKEFVICogOS41KSwgb3JiaXRBbmdsZTogZ2V0UmFuZG9tQXJiaXRyYXJ5KDM2MCwzNjApLCBvcmJpdFNwZWVkOiAwLjE4LCByb3RhdGVTcGVlZDogMC4wNSwgaW1nOicuL2Fzc2V0cy9tb2RlbC9zYXR1cm4ucG5nJ30sXG4gICAgICAgIHtuYW1lOiAnVXJhbnVzJywgc2l6ZTogMTIuNywgb3JiaXRSYWRpdXM6IHN1blNpemUgKyAoQVUgKiAxOS4yKSwgb3JiaXRBbmdsZTogZ2V0UmFuZG9tQXJiaXRyYXJ5KDM2MCwzNjApLCBvcmJpdFNwZWVkOiAwLjEzLCByb3RhdGVTcGVlZDogMC4wNSwgaW1nOicuL2Fzc2V0cy9tb2RlbC91cmFudXMuanBlZyd9LFxuICAgICAgICB7bmFtZTogJ05lcHR1bmUnLCBzaXplOiAxMi4zLCBvcmJpdFJhZGl1czogc3VuU2l6ZSArIChBVSAqIDMwLjEpLCBvcmJpdEFuZ2xlOiBnZXRSYW5kb21BcmJpdHJhcnkoMzYwLDM2MCksIG9yYml0U3BlZWQ6IDAuMSwgcm90YXRlU3BlZWQ6IDAuMDUsIGltZzonLi9hc3NldHMvbW9kZWwvbmVwdHVuZS5qcGVnJ30sXG4gICAgICAgIHtuYW1lOiAnU3VuJywgc2l6ZTogc3VuU2l6ZSwgb3JiaXRSYWRpdXM6IDAsIG9yYml0QW5nbGU6IDAsIG9yYml0U3BlZWQ6IDAuMSwgcm90YXRlU3BlZWQ6IDAuMDUsIGltZzonLi9hc3NldHMvbW9kZWwvc3VuLmpwZyd9LFxuICAgIF07XG4gICAgdmFyIFNoYWRlcnMgPSB7XG4gICAgICAgICdlYXJ0aCcgOiB7XG4gICAgICAgICAgICB1bmlmb3Jtczoge30sXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFtcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZOb3JtYWw7JyxcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAgICAgJ3ZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApOycsXG4gICAgICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTsnLFxuICAgICAgICAgICAgICAgICd9J1xuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2Tm9ybWFsOycsXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgICAgICdmbG9hdCBpbnRlbnNpdHkgPSBwb3coIDAuOCAtIGRvdCggdk5vcm1hbCwgdmVjMyggMCwgMCwgMS4wICkgKSwgMTIuMCApOycsXG4gICAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMDc0LCAwLjk5NiwgMC45OTIsIDEuMCApICogaW50ZW5zaXR5OycsXG4gICAgICAgICAgICAgICAgJ30nXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgICAgIH0sXG4gICAgICAgICdhdG1vc3BoZXJlJyA6IHtcbiAgICAgICAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogW1xuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzMgdk5vcm1hbDsnLFxuICAgICAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgICAgICAndk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7JyxcbiAgICAgICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOycsXG4gICAgICAgICAgICAgICAgJ30nXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFtcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZOb3JtYWw7JyxcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IGludGVuc2l0eSA9IHBvdyggMC44IC0gZG90KCB2Tm9ybWFsLCB2ZWMzKCAwLCAwLCAxLjAgKSApLCAxMi4wICk7JyxcbiAgICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC45OTYsIDAuNTQ0LCAwLjA5MiwgMS4wICkgKiBpbnRlbnNpdHk7JyxcbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgIF0uam9pbignXFxuJylcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHRleHRNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmIH0pO1xuICAgIGxldCBtZXJjdXJ5VGV4dCA9IG5ldyBUSFJFRS5NZXNoKCk7XG4gICAgbGV0IHZlbnVzVGV4dCA9IG5ldyBUSFJFRS5NZXNoKCk7XG4gICAgbGV0IG1hcnNUZXh0ID0gbmV3IFRIUkVFLk1lc2goKTtcbiAgICBsZXQgZWFydGhUZXh0ID0gbmV3IFRIUkVFLk1lc2goKTtcbiAgICBsZXQganVwaXRlclRleHQgPSBuZXcgVEhSRUUuTWVzaCgpO1xuICAgIGxldCBzYXR1cm5UZXh0ID0gbmV3IFRIUkVFLk1lc2goKTtcbiAgICBsZXQgdXJhbnVzVGV4dCA9IG5ldyBUSFJFRS5NZXNoKCk7XG4gICAgbGV0IG5lcHR1bmVUZXh0ID0gbmV3IFRIUkVFLk1lc2goKTtcbiAgICBjb25zdCBtZXJjdXJ5ID0gY3JlYXRlU3RhcnMocGxhbmV0RGF0YVswXS5zaXplLCBwbGFuZXREYXRhWzBdLmltZywgMTAsIFwiTWVyY3VyeVwiKTtcbiAgICBjb25zdCB2ZW51cyA9IGNyZWF0ZVN0YXJzKHBsYW5ldERhdGFbMV0uc2l6ZSwgcGxhbmV0RGF0YVsxXS5pbWcsIDI1LCBcIlZlbnVzXCIpO1xuICAgIGNvbnN0IGVhcnRoID1jcmVhdGVTdGFycyhwbGFuZXREYXRhWzJdLnNpemUsIHBsYW5ldERhdGFbMl0uaW1nLCA0MCwgXCJFYXJ0aFwiKTtcbiAgICBjb25zdCBtYXJzID1jcmVhdGVTdGFycyhwbGFuZXREYXRhWzNdLnNpemUsIHBsYW5ldERhdGFbM10uaW1nLCAxMCwgXCJNYXJzXCIpO1xuICAgIGNvbnN0IGp1cGl0ZXIgPWNyZWF0ZVN0YXJzKHBsYW5ldERhdGFbNF0uc2l6ZSwgcGxhbmV0RGF0YVs0XS5pbWcsIDEwLCBcIkp1cGl0ZXJcIik7XG4gICAgY29uc3Qgc2F0dXJuID1jcmVhdGVTdGFycyhwbGFuZXREYXRhWzVdLnNpemUsIHBsYW5ldERhdGFbNV0uaW1nLCAxMCwgXCJTYXR1cm5cIik7XG4gICAgY29uc3QgdXJhbnVzID1jcmVhdGVTdGFycyhwbGFuZXREYXRhWzZdLnNpemUsIHBsYW5ldERhdGFbNl0uaW1nLCAxMCwgXCJVcmFudXNcIik7XG4gICAgY29uc3QgbmVwdHVuZSA9Y3JlYXRlU3RhcnMocGxhbmV0RGF0YVs3XS5zaXplLCBwbGFuZXREYXRhWzddLmltZywgMTAsIFwiTmVwdHVuZVwiKTtcbiAgICBjb25zdCBzdW4gPSBjcmVhdGVTdGFycyhwbGFuZXREYXRhWzhdLnNpemUsIHBsYW5ldERhdGFbOF0uaW1nLCA1MCwgXCJTdW5cIik7XG4vL3N1biBnbG93XG4gICAgY3JlYXRlR2xvdyhzdW4sIG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShzdW5TaXplLCA1MCwgNTApLCBTaGFkZXJzWydhdG1vc3BoZXJlJ10sIDEuMDIpO1xuICAgIC8vY3JlYXRlR2xvdyhlYXJ0aCwgbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDMsIDQwLCA0MCksIFNoYWRlcnNbJ2VhcnRoJ10sIDEuMDMpOyAvL2VhcnRoR2xvd1xuXG4gICAgbGV0IGFsbFRleHQgPSBbXTtcbiAgICBsZXQgZWFydGhEYXRhR2VvLCBlYXJ0aERhdGFNZXNoO1xuICAgIGxldCBiYXNlR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgbGV0IGJhc2VNZXNoO1xuICAgIGxldCB0ZXh0U2l6ZSA9IDM7XG4gICAgbGV0IHRvb2x0aXBHZW8sIHRvb2x0aXBNZXNoO1xuICAgIGxldCBwcmVTZWxlY3RlZD0geydDb3VudHJ5JzonJ307XG4gICAgbGV0IHRvb2x0aXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd5d190b29sdGlwJylbMF07XG5cbiAgICBmdW5jdGlvbiBpbml0KCkge1xuXG4gICAgICAgIHNjZW5lLmFkZChjYW1lcmEpO1xuICAgICAgICBzY2VuZS5hZGQobmV3IFRIUkVFLkFtYmllbnRMaWdodCgweGZmZmZmZikpO1xuXG4gICAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29sYXItY2FudmFzJykuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7Ly9BIGNhbnZhcyBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYnkgdGhlIHJlbmRlcmVyIGluIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICAvLyBjb250cm9scywgY2FtZXJhXG4gICAgICAgIGNvbnRyb2xzID0gbmV3IFRIUkVFLk9yYml0Q29udHJvbHMoIGNhbWVyYSwgcmVuZGVyZXIuZG9tRWxlbWVudCApO1xuICAgICAgICBjb250cm9scy5lbmFibGVab29tID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xzLnRhcmdldC5zZXQoIDM3NSwgMCwgMCApO1xuICAgICAgICBjYW1lcmEucG9zaXRpb24uc2V0KCAzNzUsIDAsIDIwMDAgKTtcbiAgICAgICAgLy8gY2FtZXJhLnBvc2l0aW9uLnNldCggMjAwLCAxOCwgMjAwMCApO1xuICAgICAgICBjb250cm9scy51cGRhdGUoKTsvL211c3QgYmUgY2FsbGVkIGFmdGVyIGFueSBtYW51YWwgY2hhbmdlcyB0byB0aGUgY2FtZXJhJ3MgdHJhbnNmb3JtXG5cbiAgICAgICAgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgICAgIC8vZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NvbGFyLWNhbnZhcycpLmFwcGVuZENoaWxkKCBzdGF0cy5kb20gKTtcblxuICAgICAgICAvL2NyZWF0ZSBzYXR1cm4gcmluZ1xuICAgICAgICBjb25zdCBzYXR1cm5TaXplID0gMjkuMTtcbiAgICAgICAgbGV0IHNhdHVyblJpbmdNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgIG1hcDogVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSgnLi9hc3NldHMvbW9kZWwvc2F0dXJuUmluZy5wbmcnKSxcbiAgICAgICAgICAgIGZsYXRTaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzYXR1cm5SaW5nU3RhcnQgPSBzYXR1cm5TaXplICsgMy4zO1xuICAgICAgICBjb25zdCBzYXR1cm5SaW5nRW5kID0gc2F0dXJuU2l6ZSArIDYwO1xuICAgICAgICBjb25zdCBzYXR1cm5SaW5nID0gbmV3IFRIUkVFLk1lc2goIG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoc2F0dXJuUmluZ1N0YXJ0LCBzYXR1cm5SaW5nRW5kLCAzMCksIHNhdHVyblJpbmdNYXRlcmlhbCk7XG4gICAgICAgIHNhdHVybi5hZGQoc2F0dXJuUmluZyk7XG4gICAgICAgIHNhdHVyblJpbmcucm90YXRpb24ueCA9IDkwICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICBuZXcgVEhSRUUuRm9udExvYWRlcigpLmxvYWQoJy4vYXNzZXRzL21vZGVsL2hlbHZldGlrZXJfcmVndWxhci50eXBlZmFjZS5qc29uJywgZnVuY3Rpb24oZm9udCkge1xuICAgICAgICAgICAgbWVyY3VyeVRleHQgPSBjcmVhdGVUZXh0KG1lcmN1cnksIG1lcmN1cnlUZXh0LCBwbGFuZXREYXRhWzBdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgdmVudXNUZXh0ID0gY3JlYXRlVGV4dCh2ZW51cywgdmVudXNUZXh0LCBwbGFuZXREYXRhWzFdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgZWFydGhUZXh0ID0gY3JlYXRlVGV4dChlYXJ0aCwgZWFydGhUZXh0LCBwbGFuZXREYXRhWzJdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgbWFyc1RleHQgPSBjcmVhdGVUZXh0KG1hcnMsIG1hcnNUZXh0LCBwbGFuZXREYXRhWzNdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgc2F0dXJuVGV4dCA9IGNyZWF0ZVRleHQoc2F0dXJuLCBzYXR1cm5UZXh0LCBwbGFuZXREYXRhWzRdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAganVwaXRlclRleHQgPSBjcmVhdGVUZXh0KGp1cGl0ZXIsIGp1cGl0ZXJUZXh0LCBwbGFuZXREYXRhWzVdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgdXJhbnVzVGV4dCA9IGNyZWF0ZVRleHQodXJhbnVzLCB1cmFudXNUZXh0LCBwbGFuZXREYXRhWzZdLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgbmVwdHVuZVRleHQgPSBjcmVhdGVUZXh0KG5lcHR1bmUsIG5lcHR1bmVUZXh0LCBwbGFuZXREYXRhWzddLm5hbWUsIGZvbnQpO1xuICAgICAgICAgICAgYWxsVGV4dD1bbWVyY3VyeVRleHQsIHZlbnVzVGV4dCwgZWFydGhUZXh0LCBtYXJzVGV4dCwgc2F0dXJuVGV4dCwganVwaXRlclRleHQsIHVyYW51c1RleHQsIG5lcHR1bmVUZXh0XTtcbiAgICAgICAgfSk7XG4vL2N1YmVcbiAgICAgICAgY29uc3QgZWFydGhDdWJlU2l6ZSA9IDEwO1xuICAgICAgICBlYXJ0aERhdGFHZW8gPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIGVhcnRoQ3ViZVNpemUsIGVhcnRoQ3ViZVNpemUsIGVhcnRoQ3ViZVNpemUsIDEgKTtcbiAgICAgICAgZWFydGhEYXRhR2VvLmFwcGx5TWF0cml4KG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKDAsMCwtMC41KSk7XG4gICAgICAgIGVhcnRoRGF0YU1lc2ggPSBuZXcgVEhSRUUuTWVzaChlYXJ0aERhdGFHZW8pO1xuXG4gICAgICAgIC8vaGVscGVyXG4gICAgICAgIC8vIGd1aS5hZGQoY2FtZXJhLnBvc2l0aW9uLCAneCcsIC0yMDAwLCAxMDAwMCk7XG4gICAgICAgIC8vIGd1aS5hZGQoY2FtZXJhLnBvc2l0aW9uLCAneScsIC0yMDAwLCAxMDAwMCk7XG4gICAgICAgIC8vIGd1aS5hZGQoY2FtZXJhLnBvc2l0aW9uLCAneicsIC0yMDAwLCAxMDAwMCk7XG5cbiAgICAgICAgYWRkRGF0YSgpO1xuXG4gICAgICAgIC8vdG9vbHRpcFxuXG4gICAgICAgIHRvb2x0aXBHZW8gPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTAsIDEwLCAxMCwgMSk7XG4gICAgICAgIHRvb2x0aXBHZW8uYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oMCwwLC0wLjUpKTtcbiAgICAgICAgY29uc3QgdG9vbHRpcE1hdCA9ICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtjb2xvcjogMHhmZmZmZmZ9ICk7XG4gICAgICAgIHRvb2x0aXBNZXNoID0gbmV3IFRIUkVFLk1lc2godG9vbHRpcEdlbyx0b29sdGlwTWF0KTtcbiAgICAgICAgdG9vbHRpcE1lc2gubmFtZSA9ICd0b29sdGlwX21lc2gnO1xuICAgICAgICBzY2VuZS5hZGQodG9vbHRpcE1lc2gpO1xuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUZXh0KHBsYW5ldCwgcGxhbmV0VGV4dCwgdGV4dCwgZm9udCkge1xuICAgICAgICBjb25zdCB0ZXh0R2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KHRleHQsIHtcbiAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICBzaXplOiB0ZXh0U2l6ZSxcbiAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHBsYW5ldFRleHQgPSBuZXcgVEhSRUUuTWVzaCh0ZXh0R2VvbWV0cnksIHRleHRNYXRlcmlhbCk7XG4gICAgICAgIHBsYW5ldC5hZGQocGxhbmV0VGV4dCk7XG4gICAgICAgIHJldHVybiBwbGFuZXRUZXh0XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1heChkYXRhLCBhdHRyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnJlZHVjZSgobWF4LCBwKSA9PiBwW2F0dHJdID4gbWF4ID8gcFthdHRyXSA6IG1heCwgZGF0YVswXVthdHRyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJhbmRvbUFyYml0cmFyeShtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwbGFuZXRSb3RhdGUocGxhbmV0LCB0ZXh0LCBpZCwgeVRleHRQb3MsIHhUZXh0UG9zLCB0ZXh0U2l6ZSkge1xuICAgICAgICBpZigheVRleHRQb3MpIHlUZXh0UG9zPTA7XG4gICAgICAgIHZhciBkYXRhID0gcGxhbmV0RGF0YVtpZF07XG4gICAgICAgIC8vbGV0IHJhZGlhbnMgPSBwbGFuZXREYXRhW2lkXS5vcmJpdEFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgcGxhbmV0LnBvc2l0aW9uLnggPSBwbGFuZXREYXRhW2lkXS5vcmJpdFJhZGl1cztcbiAgICAgICAgcGxhbmV0LnBvc2l0aW9uLnogPSAwO1xuICAgICAgICBwbGFuZXQucG9zaXRpb24ueSA9IDA7XG4gICAgICAgIC8vcGxhbmV0LnJvdGF0aW9uLnkgKz0gcGxhbmV0RGF0YVtpZF0ucm90YXRlU3BlZWQ7XG4gICAgICAgIHRleHQucG9zaXRpb24ueCA9IHBsYW5ldERhdGFbaWRdLnNpemUgKyB4VGV4dFBvcy9jYW1lcmEuem9vbTtcbiAgICAgICAgdGV4dC5wb3NpdGlvbi55ID15VGV4dFBvcztcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gMDtcbiAgICAgICAgdGV4dC5zY2FsZS5zZXQodGV4dFNpemUsdGV4dFNpemUsdGV4dFNpemUpO1xuICAgICAgICAvLyB0ZXh0LnNjYWxlKClcbiAgICAgICAgdGV4dC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7IC8vVXBkYXRlcyB0aGUgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4LiBNdXN0IGJlIGNhbGxlZCBhZnRlciBhbnkgY2hhbmdlIG9mIHBhcmFtZXRlcnMuXG4gICAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdGFycyhzaXplLCBpbWcsIHNlZ21lbnQsIG5hbWUpIHtcbiAgICAgICAgbGV0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgIG1hcDogdGV4dHVyZUxvYWRlci5sb2FkKGltZyksXG4gICAgICAgICAgICBmbGF0U2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGxhbmV0ID0gbmV3IFRIUkVFLk1lc2gobmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHNpemUsIHNlZ21lbnQsIHNlZ21lbnQpLCBtYXRlcmlhbCk7XG4gICAgICAgIHBsYW5ldC5uYW1lID0gbmFtZTtcbiAgICAgICAgc2NlbmUuYWRkKHBsYW5ldCk7XG4gICAgICAgIHJldHVybiBwbGFuZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRGF0YSgpe1xuLy8gUHJvbWlzZVxuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHJlcXVlc3QoJ0dFVCcsICcuL2Fzc2V0cy9tb2RlbC9hbGxDb3VudHJpZXMuanNvbicpO1xuLy8gY2FsbCBvdXIgcHJvbWlzZVxuICAgICAgICByZXF1ZXN0RGF0YVxuICAgICAgICAgICAgLnRoZW4ocHJvY2Vzc0RhdGEpXG4gICAgICAgICAgICAudGhlbihhZGRUb0VhcnRoKVxuICAgICAgICAgICAgLnRoZW4oZnVsZmlsbGVkID0+IGNvbnNvbGUubG9nKGZ1bGZpbGxlZCkpXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gY29uc29sZS5sb2coZXJyb3IubWVzc2FnZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBKU09OLnBhcnNlKGRhdGEudGFyZ2V0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2Nlc3MgZGF0YScpO1xuICAgICAgICAgICAgICAgIG5ld0RhdGEuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRQb2ludCgrdC5MYXRpdHVkZSwrdC5Mb25naXR1ZGUsIDAsIGdldENvbG9yKCt0WydQb3B1bGF0aW9uJ10pLCBiYXNlR2VvKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICAgICAgYmFzZUdlby5tb3JwaFRhcmdldHMucHVzaCh7J25hbWUnOiAndGFyZ2V0LScrMCwgdmVydGljZXM6IGJhc2VHZW8udmVydGljZXN9KTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTwzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gY2F0ZWdvcnlbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heEluQXR0ciA9IGdldE1heChuZXdEYXRhLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXR0ciwgbWF4SW5BdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YkdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSArZFthdHRyXS9tYXhJbkF0dHIvMjsgLy8gbGluZWFyU2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50KCtkLkxhdGl0dWRlLCtkLkxvbmdpdHVkZSwgc2l6ZSwgZ2V0Q29sb3Ioc2l6ZSksIHN1Ykdlbyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIGJhc2VHZW8ubW9ycGhUYXJnZXRzLnB1c2goeyduYW1lJzogJ3RhcmdldC0nKyhpKzEpLCB2ZXJ0aWNlczogc3ViR2VvLnZlcnRpY2VzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVG9FYXJ0aCgpIHtcbiAgICAgICAgYmFzZU1lc2g9IG5ldyBUSFJFRS5NZXNoKGJhc2VHZW8sIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICBjb2xvcjogMHhmZmZmMDAsXG4gICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHM6IHRydWUsXG4gICAgICAgIH0pKVxuICAgICAgICBlYXJ0aC5hZGQoYmFzZU1lc2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhiYXNlTWVzaCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnYWRkZWQgYmFzZU1lc2gnO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdsb3cocGxhbmV0LCBnZW9tZXRyeSwgc2hhZGVyLCBzY2FsZSkge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoc2hhZGVyLnVuaWZvcm1zKTtcblxuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG5cbiAgICAgICAgICAgIHVuaWZvcm1zOiB1bmlmb3JtcyxcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZSxcbiAgICAgICAgICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICAgICAgLy8gdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgbWVzaC5zY2FsZS5zZXQoIHNjYWxlLCBzY2FsZSwgc2NhbGUgKTtcbiAgICAgICAgbWVzaC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIG1lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHBsYW5ldC5hZGQobWVzaCk7IC8vIHRoZSBnbG93XG4gICAgfVxuLy8gYW5pbWF0ZSgpO1xuICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gTWF0aC5zcXJ0KGNhbWVyYS56b29tKS50b0ZpeGVkKDIpO1xuICAgICAgICBjb25zdCB4VGV4dFBvcyA9IDMwIC8gcGFyYW07XG4gICAgICAgIGNvbnN0IG5ld1RleHRTaXplID0gdGV4dFNpemUvY2FtZXJhLnpvb207XG4gICAgICAgIHBsYW5ldFJvdGF0ZShtZXJjdXJ5LCBtZXJjdXJ5VGV4dCwgMCwgLTMwL3BhcmFtLCB4VGV4dFBvcywgbmV3VGV4dFNpemUpO1xuICAgICAgICBwbGFuZXRSb3RhdGUodmVudXMsIHZlbnVzVGV4dCwgMSwgLTE1L3BhcmFtLCB4VGV4dFBvcywgbmV3VGV4dFNpemUpO1xuICAgICAgICBwbGFuZXRSb3RhdGUoZWFydGgsIGVhcnRoVGV4dCwgMiwgMC9wYXJhbSwgeFRleHRQb3MsIG5ld1RleHRTaXplKTtcbiAgICAgICAgcGxhbmV0Um90YXRlKG1hcnMsIG1hcnNUZXh0LCAzLCAxNS9wYXJhbSwgeFRleHRQb3MsIG5ld1RleHRTaXplKTtcbiAgICAgICAgcGxhbmV0Um90YXRlKGp1cGl0ZXIsIGp1cGl0ZXJUZXh0LCA0LCAzMC9wYXJhbSwgeFRleHRQb3MsIG5ld1RleHRTaXplKTtcbiAgICAgICAgcGxhbmV0Um90YXRlKHNhdHVybiwgc2F0dXJuVGV4dCwgNSwgMzAvcGFyYW0sIHhUZXh0UG9zLCBuZXdUZXh0U2l6ZSk7XG4gICAgICAgIHBsYW5ldFJvdGF0ZSh1cmFudXMsIHVyYW51c1RleHQsIDYsIDEwL3BhcmFtLCB4VGV4dFBvcywgbmV3VGV4dFNpemUpO1xuICAgICAgICBwbGFuZXRSb3RhdGUobmVwdHVuZSwgbmVwdHVuZVRleHQsIDcsIDEwL3BhcmFtLCB4VGV4dFBvcywgbmV3VGV4dFNpemUpO1xuICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICBzdW4ucG9zaXRpb24ueCA9IDA7XG4gICAgICAgIHN1bi5wb3NpdGlvbi56ID0gMDtcbiAgICAgICAgc3VuLnBvc2l0aW9uLnkgPSAwO1xuICAgICAgICAvL3N0YXRzLnVwZGF0ZSgpO1xuICAgICAgICBUV0VFTi51cGRhdGUoKTtcbiAgICAgICAgLy9UaGUgY29kZSBiZWxvdyBkb2Vzbid0IHdvcmsuIEl0IGNhbm5vdCBnZXQgcmlnaHQgdGV4dHNcbiAgICAgICAgLy8gZWlnaHRQbGFuZXRzLmZvckVhY2goZnVuY3Rpb24gKHBsYW5ldCwgaWQpIHtcbiAgICAgICAgLy8gICAgIHBsYW5ldFJvdGF0ZShwbGFuZXQsIGFsbFRleHRbaWRdLCBpZCk7XG4gICAgICAgIC8vIH0pXG5cbiAgICAgICAgcmVuZGVyKCk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNocmlua0ZvbnRzKCl7XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFBvaW50KGxhdCwgbG5nLCBzaXplLCBjb2xvciwgZ2VvKSB7XG4gICAgICAgIHZhciBwaGkgPSAoOTAgLSBsYXQpICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIHRoZXRhID0gKDM2MCAtIGxuZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICBjb25zdCByID0gM1xuICAgICAgICBlYXJ0aERhdGFNZXNoLnBvc2l0aW9uLnggPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgZWFydGhEYXRhTWVzaC5wb3NpdGlvbi55ID0gciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIGVhcnRoRGF0YU1lc2gucG9zaXRpb24ueiA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBlYXJ0aERhdGFNZXNoLnNjYWxlLnogPSAtc2l6ZTtcbiAgICAgICAgZWFydGhEYXRhTWVzaC5zY2FsZS54ID0gMS80MDA7XG4gICAgICAgIGVhcnRoRGF0YU1lc2guc2NhbGUueSA9IDEvNDAwO1xuICAgICAgICBlYXJ0aERhdGFNZXNoLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApKTtcbiAgICAgICAgZWFydGhEYXRhTWVzaC51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlYXJ0aERhdGFNZXNoLmdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlYXJ0aERhdGFNZXNoLmdlb21ldHJ5LmZhY2VzW2ldLmNvbG9yID0gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWFydGhEYXRhTWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICBlYXJ0aERhdGFNZXNoLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGVhcnRoRGF0YU1lc2gpO1xuICAgICAgICBnZW8ubWVyZ2UoZWFydGhEYXRhTWVzaC5nZW9tZXRyeSwgZWFydGhEYXRhTWVzaC5tYXRyaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRG9jdW1lbnRNb3VzZU1vdmUoIGV2ZW50ICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtb3VzZS54ID0gKCBldmVudC5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGggKSAqIDIgLSAxO1xuICAgICAgICBtb3VzZS55ID0gLSAoIGV2ZW50LmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKSAqIDIgKyAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbG9yKHgpIHtcblxuICAgICAgICBjb25zdCBjb2xvciA9IHggPiAxMDAwMDAwMDA/IG5ldyBUSFJFRS5Db2xvcihcInJnYigyNTUsIDEzMCwgMClcIikgOiBuZXcgVEhSRUUuQ29sb3IoXCJyZ2IoMCwgMjU1LCAyNTUpXCIpXG4gICAgICAgIHJldHVybiBjb2xvclxuICAgIH07XG5cbiAgICAvL1RPRE86IGFkZCByYXljYXN0ZXIgdG8gYmFzZU1lc2hcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGNhbWVyYS5sb29rQXQoZWFydGgucG9zaXRpb24pO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCBtb3VzZSwgY2FtZXJhICk7XG4gICAgICAgIGlmKGJhc2VNZXNoIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGludGVyc2VjdHMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KCBiYXNlTWVzaCApO1xuICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3RzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBJTlRFUlNFQ1RFRCAhPSBpbnRlcnNlY3RzWyAwIF0uZmFjZUluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZE1lc2ggPSBpbnRlcnNlY3RzWzBdLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgSU5URVJTRUNURUQgPSBNYXRoLmZsb29yKGludGVyc2VjdHMgWyAwIF0uZmFjZUluZGV4LzEyKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoSU5URVJTRUNURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIElOVEVSU0VDVEVEICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIElOVEVSU0VDVEVEID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0c1swXS5vYmplY3QuZ2VvbWV0cnkuc2NhbGUobmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgdGhpcy5fX2RlZmluZVNldHRlcl9fKCd0aW1lJywgZnVuY3Rpb24odCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdzZXRUaW1lOiAnLCB0KTtcbiAgICAgICAgLy8gdD0gMCwgMS8zLCAyLzNcbiAgICAgICAgLy9tb3JwaFRyYW5zaXRpb24odCk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgIH0pO1xuXG4gICAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCd0aW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lIHx8IDA7XG4gICAgfSk7XG5cblxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKHNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNlbGYuZGF0YVtzZWxlY3RlZF07XG4gICAgICAgIGlmKHNlbGVjdGVkRGF0YSAhPSB1bmRlZmluZWQgJiZzZWxlY3RlZERhdGFbJ0NvdW50cnknXSAhPSBwcmVTZWxlY3RlZFsnQ291bnRyeSddKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNlbGVjdGVkRGF0YSk7XG4gICAgICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzZWxlY3RlZERhdGFbJ0NvdW50cnknXSk7XG4gICAgICAgICAgICB0b29sdGlwLmlubmVySFRNTCA9YDxwPjxzdHJvbmc+JHtzZWxlY3RlZERhdGFbJ0NvdW50cnknXX08L3N0cm9uZz48L2JyPlxuICAgICAgICAgICAgUG9wdWxhdGlvbjogJHthZGRDb21tYXMoc2VsZWN0ZWREYXRhWydQb3B1bGF0aW9uJ10pfTwvYnI+XG4gICAgICAgICAgICBHRFA6ICR7YWRkQ29tbWFzKHNlbGVjdGVkRGF0YVsnR0RQJ10pfSAkIHBlciBjYXBpdGE8L2JyPlxuICAgICAgICAgICAgTGl0ZXJhY3kgcmF0ZTogJHtzZWxlY3RlZERhdGFbJ0xpdGVyYWN5J119JSA8L3A+YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbW1hcyhuU3RyKSB7XG4gICAgICAgIG5TdHIgKz0gJyc7XG4gICAgICAgIHZhciB4ID0gblN0ci5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgeDEgPSB4WzBdO1xuICAgICAgICB2YXIgeDIgPSB4Lmxlbmd0aCA+IDEgPyAnLicgKyB4WzFdIDogJyc7XG4gICAgICAgIHZhciByZ3ggPSAvKFxcZCspKFxcZHszfSkvO1xuICAgICAgICB3aGlsZSAocmd4LnRlc3QoeDEpKSB7XG4gICAgICAgICAgICB4MSA9IHgxLnJlcGxhY2Uocmd4LCAnJDEnICsgJywnICsgJyQyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgxICsgeDI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmFzZU1lc2goKSB7XG4gICAgICAgIGlmKGJhc2VNZXNoIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBiYXNlTWVzaFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2FtZXJhKCkge1xuICAgICAgICByZXR1cm4gY2FtZXJhXG4gICAgfVxuXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSwgZmFsc2UgKTtcblxuICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5yZXNpemUgPSByZXNpemU7XG4gICAgdGhpcy5hbmltYXRlPSBhbmltYXRlO1xuICAgIHRoaXMuZ2V0Q2FtZXJhID0gZ2V0Q2FtZXJhO1xuICAgIHRoaXMuZ2V0QmFzZU1lc2ggPSBnZXRCYXNlTWVzaDtcblxuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyYXBoaWNcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQVRBO0FBaUJBO0FBQ0E7QUFDQTtBQU9BO0FBVEE7QUFsQkE7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFDQTtBQU9BO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n// device sniffing for mobile\n\nvar isMobile = {\n\tandroid: function android() {\n\t\treturn navigator.userAgent.match(/Android/i);\n\t},\n\n\tblackberry: function blackberry() {\n\t\treturn navigator.userAgent.match(/BlackBerry/i);\n\t},\n\n\tios: function ios() {\n\t\treturn navigator.userAgent.match(/iPhone|iPad|iPod/i);\n\t},\n\n\topera: function opera() {\n\t\treturn navigator.userAgent.match(/Opera Mini/i);\n\t},\n\n\twindows: function windows() {\n\t\treturn navigator.userAgent.match(/IEMobile/i);\n\t},\n\n\tany: function any() {\n\t\treturn isMobile.android() || isMobile.blackberry() || isMobile.ios() || isMobile.opera() || isMobile.windows();\n\t}\n};\n\nexports.default = isMobile;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvdXRpbHMvaXMtbW9iaWxlLmpzP2E5NTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZGV2aWNlIHNuaWZmaW5nIGZvciBtb2JpbGVcblxuY29uc3QgaXNNb2JpbGUgPSB7XG5cdGFuZHJvaWQ6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSksXG5cblx0YmxhY2tiZXJyeTogKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQmxhY2tCZXJyeS9pKSxcblxuXHRpb3M6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvaSksXG5cblx0b3BlcmE6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL09wZXJhIE1pbmkvaSksXG5cblx0d2luZG93czogKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvSUVNb2JpbGUvaSksXG5cblx0YW55OiAoKSA9PiAoXG5cdFx0aXNNb2JpbGUuYW5kcm9pZCgpIHx8XG5cdFx0aXNNb2JpbGUuYmxhY2tiZXJyeSgpIHx8XG5cdFx0aXNNb2JpbGUuaW9zKCkgfHxcblx0XHRpc01vYmlsZS5vcGVyYSgpIHx8XG5cdFx0aXNNb2JpbGUud2luZG93cygpXG5cdCksXG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTW9iaWxlXG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVhBO0FBQ0E7QUFtQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanM/ZjdmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _lodash = __webpack_require__(5);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _isMobile = __webpack_require__(3);\n\nvar _isMobile2 = _interopRequireDefault(_isMobile);\n\nvar _graphic = __webpack_require__(2);\n\nvar _graphic2 = _interopRequireDefault(_graphic);\n\nvar _enterView = __webpack_require__(1);\n\nvar _enterView2 = _interopRequireDefault(_enterView);\n\nvar _stickyfilljs = __webpack_require__(0);\n\nvar _stickyfilljs2 = _interopRequireDefault(_stickyfilljs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $body = d3.select('body'); // D3 is included by globally by default\n\nvar previousWidth = 0;\n\nvar container = d3.select('#main-content');\nvar stepSel = container.selectAll('.step');\nvar graphic = new _graphic2.default();\n\nfunction updateChart(index, camera) {\n    console.log('updateChart' + index);\n    var sel = container.select('[data-index=\\'' + index + '\\']');\n    stepSel.classed('is-active', function (d, i) {\n        return i === index;\n    });\n    if (index === 0) {\n        cameraTween(camera, 10000, 10000, 2000, 1);\n    } else if (index === 1) {\n        cameraTween(camera, 375, 18, 2000, 20);\n    } else if (index === 2) {\n        cameraTween(camera, 375, 8000, 2000, 150);\n    } else if (index === 3) {\n        cameraTween(camera, 425, 18, 2000, 200);\n        setTime(graphic, 0);\n    } else if (index === 4) {\n        setTime(graphic, 1);\n    } else if (index === 5) {\n        setTime(graphic, 2);\n        cameraTween(camera, 7000, 3000, 2000, 220);\n    } else if (index === 6) {\n        setTime(graphic, 3);\n        cameraTween(camera, 425, 18, 2000, 200);\n    } else if (index === 7) {\n        setTime(graphic, 0);\n        cameraTween(camera, 10000, 10000, 2000, 1);\n    }\n}\n\nfunction setTime(graphic, t) {\n    var baseMesh = graphic.getBaseMesh();\n    new TWEEN.Tween(graphic).to({ time: t / 4 }, 500).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function () {\n        // console.log(this.time);\n        if (baseMesh != undefined) {\n            var morphDict = baseMesh.morphTargetDictionary;\n            var l = 3; //3\n            var scaledt = this.time * l + 1;\n            var index = Math.floor(scaledt);\n            for (var i = 0; i < l; i++) {\n                baseMesh.morphTargetInfluences[i] = 0;\n            }\n            var lastIndex = index - 1;\n            var leftover = scaledt - index;\n            if (lastIndex >= 0) {\n                baseMesh.morphTargetInfluences[lastIndex] = 1 - leftover;\n            }\n            baseMesh.morphTargetInfluences[index] = leftover;\n        }\n    }).start();\n}\n\nfunction scrollyTelling(camera) {\n    _stickyfilljs2.default.add(d3.select('.sticky').node());\n\n    (0, _enterView2.default)({\n        selector: stepSel.nodes(),\n        offset: 0.5,\n        enter: function enter(el) {\n            var index = +d3.select(el).attr('data-index');\n            updateChart(index, camera);\n        },\n        exit: function exit(el) {\n            var index = +d3.select(el).attr('data-index');\n            index = Math.max(0, index - 1);\n            updateChart(index, camera);\n        }\n    });\n}\n\nfunction resize() {\n    // only do resize on width changes, not height\n    // (remove the conditional if you want to trigger on height change)\n    var width = $body.node().offsetWidth;\n    if (previousWidth !== width) {\n        previousWidth = width;\n        graphic.resize();\n    }\n}\n\nfunction init() {\n    // add mobile class to body tag\n    $body.classed('is-mobile', _isMobile2.default.any());\n    // setup resize event\n    window.addEventListener('resize', (0, _lodash2.default)(resize, 150));\n    // kick off graphic code\n    graphic.init();\n    graphic.animate();\n    var camera = graphic.getCamera();\n    scrollyTelling(camera);\n}\n\nfunction cameraTween(camera, x, y, z, zoom) {\n    new TWEEN.Tween(camera).to({ zoom: zoom }, 2000).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function () {\n        camera.zoom = this.zoom;\n    }).start();\n    var pos = camera.position;\n\n    new TWEEN.Tween(pos).to({ x: x, y: y, z: z }, 2000)\n    // .easing(TWEEN.Easing.Quadratic.InOut)\n    .onUpdate(function () {\n        camera.position.x = this.x;\n        camera.position.y = this.y;\n        camera.position.z = this.z;\n    }).start();\n}\ninit();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvZW50cnkuanM/NWM1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEMyBpcyBpbmNsdWRlZCBieSBnbG9iYWxseSBieSBkZWZhdWx0XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCBpc01vYmlsZSBmcm9tICcuL3V0aWxzL2lzLW1vYmlsZSc7XG5pbXBvcnQgR3JhcGhpYyBmcm9tICcuL2dyYXBoaWMnO1xuaW1wb3J0IGVudGVyVmlldyBmcm9tICdlbnRlci12aWV3JztcbmltcG9ydCBTdGlja3lmaWxsIGZyb20gJ3N0aWNreWZpbGxqcyc7XG5cbmNvbnN0ICRib2R5ID0gZDMuc2VsZWN0KCdib2R5Jyk7XG5sZXQgcHJldmlvdXNXaWR0aCA9IDA7XG5cbmNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdCgnI21haW4tY29udGVudCcpO1xuY29uc3Qgc3RlcFNlbCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5zdGVwJyk7XG5jb25zdCBncmFwaGljID0gbmV3IEdyYXBoaWMoKTtcblxuZnVuY3Rpb24gdXBkYXRlQ2hhcnQoaW5kZXgsIGNhbWVyYSkge1xuICAgIGNvbnNvbGUubG9nKCd1cGRhdGVDaGFydCcgKyBpbmRleClcbiAgICBjb25zdCBzZWwgPSBjb250YWluZXIuc2VsZWN0KGBbZGF0YS1pbmRleD0nJHtpbmRleH0nXWApO1xuICAgIHN0ZXBTZWwuY2xhc3NlZCgnaXMtYWN0aXZlJywgKGQsIGkpID0+IGkgPT09IGluZGV4KTtcbiAgICBpZihpbmRleD09PTApIHtcbiAgICAgICAgY2FtZXJhVHdlZW4oY2FtZXJhLCAxMDAwMCwgMTAwMDAsIDIwMDAsIDEpXG5cdH0gZWxzZSBpZihpbmRleD09PTEpe1xuICAgICAgICBjYW1lcmFUd2VlbihjYW1lcmEsIDM3NSwgMTgsIDIwMDAsIDIwKVxuXHR9IGVsc2UgaWYoaW5kZXg9PT0yKXtcbiAgICAgICAgY2FtZXJhVHdlZW4oY2FtZXJhLCAzNzUsIDgwMDAsIDIwMDAsIDE1MClcblx0fSBlbHNlIGlmKGluZGV4PT09Myl7XG4gICAgICAgIGNhbWVyYVR3ZWVuKGNhbWVyYSwgNDI1LCAxOCwgMjAwMCwgMjAwKVxuICAgICAgICBzZXRUaW1lKGdyYXBoaWMsIDApO1xuICAgIH0gZWxzZSBpZihpbmRleD09PTQpe1xuXHQgICAgc2V0VGltZShncmFwaGljLCAxKTtcbiAgICB9IGVsc2UgaWYoaW5kZXg9PT01KXtcbiAgICAgICAgc2V0VGltZShncmFwaGljLCAyKTtcbiAgICAgICAgY2FtZXJhVHdlZW4oY2FtZXJhLCA3MDAwLCAzMDAwLCAyMDAwLCAyMjApXG4gICAgfWVsc2UgaWYoaW5kZXg9PT02KXtcbiAgICAgICAgc2V0VGltZShncmFwaGljLCAzKTtcbiAgICAgICAgY2FtZXJhVHdlZW4oY2FtZXJhLCA0MjUsIDE4LCAyMDAwLCAyMDApXG4gICAgfSBlbHNlIGlmKGluZGV4PT09Nyl7XG4gICAgICAgIHNldFRpbWUoZ3JhcGhpYywgMCk7XG4gICAgICAgIGNhbWVyYVR3ZWVuKGNhbWVyYSwgMTAwMDAsIDEwMDAwLCAyMDAwLCAxKVxuICAgIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHNldFRpbWUgKGdyYXBoaWMsIHQpIHtcbiAgICBsZXQgYmFzZU1lc2ggPSBncmFwaGljLmdldEJhc2VNZXNoKCk7XG4gICAgbmV3IFRXRUVOLlR3ZWVuKGdyYXBoaWMpXG4gICAgICAgIC50byh7dGltZTogdC80fSwgNTAwKVxuICAgICAgICAuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuSW5PdXQpXG4gICAgICAgIC5vblVwZGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGltZSk7XG4gICAgICAgICAgICBpZihiYXNlTWVzaCE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ycGhEaWN0ID0gYmFzZU1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5O1xuICAgICAgICAgICAgICAgIHZhciBsID0gMzsgLy8zXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZHQgPSB0aGlzLnRpbWUqbCsxO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3Ioc2NhbGVkdCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wO2k8bDtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZU1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdG92ZXIgPSBzY2FsZWR0IC0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VNZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tsYXN0SW5kZXhdID0gMSAtIGxlZnRvdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXNlTWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaW5kZXhdID0gbGVmdG92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5zdGFydCgpO1xufVxuXG5mdW5jdGlvbiBzY3JvbGx5VGVsbGluZyhjYW1lcmEpIHtcbiAgICBTdGlja3lmaWxsLmFkZChkMy5zZWxlY3QoJy5zdGlja3knKS5ub2RlKCkpO1xuXG4gICAgZW50ZXJWaWV3KHtcbiAgICAgICAgc2VsZWN0b3I6IHN0ZXBTZWwubm9kZXMoKSxcbiAgICAgICAgb2Zmc2V0OiAwLjUsXG4gICAgICAgIGVudGVyOiBlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9ICtkMy5zZWxlY3QoZWwpLmF0dHIoJ2RhdGEtaW5kZXgnKTtcbiAgICAgICAgICAgIHVwZGF0ZUNoYXJ0KGluZGV4LCBjYW1lcmEpO1xuICAgICAgICB9LFxuICAgICAgICBleGl0OiBlbCA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSArZDMuc2VsZWN0KGVsKS5hdHRyKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4IC0gMSk7XG4gICAgICAgICAgICB1cGRhdGVDaGFydChpbmRleCwgY2FtZXJhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZXNpemUoKSB7XG5cdC8vIG9ubHkgZG8gcmVzaXplIG9uIHdpZHRoIGNoYW5nZXMsIG5vdCBoZWlnaHRcblx0Ly8gKHJlbW92ZSB0aGUgY29uZGl0aW9uYWwgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciBvbiBoZWlnaHQgY2hhbmdlKVxuXHRjb25zdCB3aWR0aCA9ICRib2R5Lm5vZGUoKS5vZmZzZXRXaWR0aDtcblx0aWYgKHByZXZpb3VzV2lkdGggIT09IHdpZHRoKSB7XG5cdFx0cHJldmlvdXNXaWR0aCA9IHdpZHRoO1xuXHRcdGdyYXBoaWMucmVzaXplKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcblx0Ly8gYWRkIG1vYmlsZSBjbGFzcyB0byBib2R5IHRhZ1xuXHQkYm9keS5jbGFzc2VkKCdpcy1tb2JpbGUnLCBpc01vYmlsZS5hbnkoKSk7XG5cdC8vIHNldHVwIHJlc2l6ZSBldmVudFxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2UocmVzaXplLCAxNTApKTtcblx0Ly8ga2ljayBvZmYgZ3JhcGhpYyBjb2RlXG5cdGdyYXBoaWMuaW5pdCgpO1xuXHRncmFwaGljLmFuaW1hdGUoKTtcblx0bGV0IGNhbWVyYSA9IGdyYXBoaWMuZ2V0Q2FtZXJhKCk7XG4gICAgc2Nyb2xseVRlbGxpbmcoY2FtZXJhKTtcbn1cblxuZnVuY3Rpb24gY2FtZXJhVHdlZW4oY2FtZXJhLCB4LHkseix6b29tKXtcbiAgICBuZXcgVFdFRU4uVHdlZW4oY2FtZXJhKVxuICAgICAgICAudG8oe3pvb206IHpvb219LCAyMDAwKVxuICAgICAgICAuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuSW5PdXQpXG4gICAgICAgIC5vblVwZGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgXHRjYW1lcmEuem9vbSA9IHRoaXMuem9vbTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0YXJ0KCk7XG4gICAgbGV0IHBvcyA9IGNhbWVyYS5wb3NpdGlvbjtcblxuICAgIG5ldyBUV0VFTi5Ud2Vlbihwb3MpXG4gICAgICAgIC50byh7eDp4LCB5OnksIHo6en0sIDIwMDApXG4gICAgICAgIC8vIC5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dClcbiAgICAgICAgLm9uVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggPSB0aGlzLng7XG4gICAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueSA9IHRoaXMueTtcbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy56O1xuICAgICAgICB9KVxuICAgICAgICAuc3RhcnQoKTtcbn1cbmluaXQoKTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")}]);